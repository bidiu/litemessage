{"version":3,"sources":["/Users/sunhe/Documents/projects/litemessage/webpack/bootstrap","/Users/sunhe/Documents/projects/litemessage/src/utils/litecrypto.js","/Users/sunhe/Documents/projects/litemessage/external \"events\"","/Users/sunhe/Documents/projects/litemessage/src/utils/network.js","/Users/sunhe/Documents/projects/litemessage/src/utils/time.js","/Users/sunhe/Documents/projects/litemessage/src/utils/common.js","/Users/sunhe/Documents/projects/litemessage/external \"fs\"","/Users/sunhe/Documents/projects/litemessage/external \"leveldown\"","/Users/sunhe/Documents/projects/litemessage/external \"levelup\"","/Users/sunhe/Documents/projects/litemessage/src/litenode.js","/Users/sunhe/Documents/projects/litemessage/external \"url\"","/Users/sunhe/Documents/projects/litemessage/src/p2pprotocol/p2protocol.js","/Users/sunhe/Documents/projects/litemessage/external \"path\"","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/entities/block.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/messages.js","/Users/sunhe/Documents/projects/litemessage/index.js","/Users/sunhe/Documents/projects/litemessage/src/client/client.js","/Users/sunhe/Documents/projects/litemessage/src/wss.js","/Users/sunhe/Documents/projects/litemessage/external \"ws\"","/Users/sunhe/Documents/projects/litemessage/src/peer.js","/Users/sunhe/Documents/projects/litemessage/external \"uuid/v1\"","/Users/sunhe/Documents/projects/litemessage/src/client/protocol.js","/Users/sunhe/Documents/projects/litemessage/external \"dns\"","/Users/sunhe/Documents/projects/litemessage/external \"util\"","/Users/sunhe/Documents/projects/litemessage/src/p2pprotocol/store.js","/Users/sunhe/Documents/projects/litemessage/src/p2pprotocol/messages.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/entities/litemsg.js","/Users/sunhe/Documents/projects/litemessage/external \"child_process\"","/Users/sunhe/Documents/projects/litemessage/external \"crypto\"","/Users/sunhe/Documents/projects/litemessage/external \"bluebird\"","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/liteprotocol.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/store.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/miner.js","/Users/sunhe/Documents/projects/litemessage/src/utils/blockchain.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/rest.js","/Users/sunhe/Documents/projects/litemessage/external \"http\"","/Users/sunhe/Documents/projects/litemessage/external \"express\"","/Users/sunhe/Documents/projects/litemessage/external \"morgan\"","/Users/sunhe/Documents/projects/litemessage/external \"cookie-parser\"","/Users/sunhe/Documents/projects/litemessage/external \"body-parser\"","/Users/sunhe/Documents/projects/litemessage/src/fullnode.js"],"names":[],"mappings":";;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;AClFA,OAAO,OAAO;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,8BAA8B,UAAU,EAAE,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,sBAAsB;AAC9B;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAyC,0CAA0C;AACnF;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;;AAEnC,OAAO,wCAAwC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,OAAO;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA,eAAe,cAAc;;AAE7B,OAAO,uDAAuD;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,gBAAgB,EAAE,WAAW,EAAE,KAAK,EAAE,MAAM;AACzF;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,cAAc;AAChD;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,cAAc;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7NA,mC;;;;;;ACAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,yBAAyB,GAAG,sBAAsB;AAC9D;;AAEA;AACA;AACA;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;ACbA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,0CAA0C;;AAErE;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACzDA,+B;;;;;;ACAA,sC;;;;;;ACAA,oC;;;;;;ACAA;AACA;AACA;AACA;AACA,OAAO,mBAAmB;AAC1B,OAAO,kBAAkB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB,KAAK;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD,OAAO;AAC9D;AACA;AACA,qBAAqB,UAAU,4BAA4B,KAAK;AAChE,uBAAuB,uCAAuC;AAC9D,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB,GAAG,cAAc;AAChF,KAAK;AACL,+CAA+C,iBAAiB,GAAG,cAAc;AACjF;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,cAAc;AACtF;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,qBAAqB;AAC7F;AACA;AACA;AACA;AACA;AACA,0DAA0D,cAAc,mBAAmB;AAC3F;AACA;AACA;AACA;AACA;AACA,oEAAoE,WAAW,GAAG,cAAc,EAAE;AAClG;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,0BAA0B,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,2BAA2B,sBAAsB;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,WAAW,GAAG,cAAc,IAAI,cAAc,KAAK,gBAAgB;AAC1G;AACA;AACA;AACA,KAAK;AACL,wCAAwC,cAAc,IAAI,cAAc,KAAK,gBAAgB;AAC7F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACpNA,gC;;;;;;ACAA;AACA,OAAO,MAAM;AACb,OAAO,YAAY;AACnB;AACA;AACA;AACA,CAAC;AACD,OAAO,YAAY;;AAEnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA,gCAAgC,iBAAiB,KAAK;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,2BAA2B;AAC3D,gCAAgC,4BAA4B;;AAE5D;;AAEA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;;AAEA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA,KAAK;AACL;AACA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;AACA;AACA;;AAEA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC/HA,iC;;;;;;ACAA,OAAO,SAAS;;AAEhB;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,KAAK,EAAE,MAAM;AACjF;AACA,UAAU;AACV;;AAEA;;;;;;;ACvBA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;;AAED,oBAAoB,gBAAgB;AACpC;AACA;AACA,CAAC;;AAED,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA,CAAC;;AAED,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA,CAAC;;AAED,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA,CAAC;;AAED,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,CAAC;;AAED;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+BAA+B;;AAE/B,8BAA8B;AAC9B,8BAA8B;;AAE9B;;AAEA,CAAC,QAID;;;;;;;ACnBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC,iCAAiC,KAAK;AAC5E;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C,OAAO;;AAEnD;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,oBAAoB;AAC9D,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC/DA;AACA;AACA,OAAO,MAAM;AACb,OAAO,mBAAmB;;AAE1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc,KAAK;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe,IAAI,UAAU;AACpD,uBAAuB,eAAe,IAAI,UAAU;AACpD,uBAAuB,eAAe,IAAI,cAAc;AACxD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAA8C;AACtD,+DAA+D,mBAAmB;AAClF,KAAK;AACL,oCAAoC,IAAI;AACxC;;AAEA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA;;AAEA;AACA;AACA,qCAAqC,iDAAiD;AACtF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oDAAoD,IAAI,cAAc,IAAI;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;AC3LA,+B;;;;;;ACAA,OAAO,mBAAmB;;AAE1B;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB,GAAG,WAAW;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,cAAc,cAAc,KAAK,SAAS;AAC1C;AACA;;AAEA;;;;;;;AC9CA,oC;;;;;;ACAA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB,KAAK;AACtD,4BAA4B,aAAa;AACzC;AACA;;AAEA;;;;;;;ACXA,gC;;;;;;ACAA,iC;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;;AAEA;;;;;;;AC9BA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,qBAAqB,wBAAwB,KAAK;AAClD;AACA;AACA;AACA,CAAC;;AAED,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,sBAAsB,2BAA2B,KAAK;AACtD;AACA;AACA;AACA,CAAC;;AAED,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;;;;;;ACvDA,OAAO,SAAS;;AAEhB;AACA,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,uBAAuB,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,OAAO;AAC3D,UAAU;AACV;;AAEA;;;;;;;ACdA,0C;;;;;;ACAA,mC;;;;;;ACAA,qC;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD,OAAO,YAAY;AACnB,OAAO,kBAAkB;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,iBAAiB,KAAK;AACtD,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,cAAc;;AAErD;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,gCAAgC,uBAAuB;AACvD,gCAAgC,iBAAiB;AACjD,gCAAgC,qBAAqB;AACrD,gCAAgC,kBAAkB;AAClD,gCAAgC,4BAA4B;AAC5D;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;;AAEA;AACA;AACA;AACA,0DAA0D,QAAQ;;AAElE;AACA;AACA;AACA,SAAS,cAAc,mBAAmB;;AAE1C,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,S;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD,UAAU,OAAO,WAAW;;AAEjF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA,WAAW,gBAAgB;AAC3B;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,+CAA+C;AAClE;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;;AAEA;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA,WAAW,mBAAmB;AAC9B,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,qCAAqC,gBAAgB;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,UAAU;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,+CAA+C;AAC9D;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,yBAAyB,0BAA0B;AACnD;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,WAAW;AACtC;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACzWA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;;AAEA,KAAK;AACL,yBAAyB,kBAAkB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,kBAAkB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA,KAAK;AACL,yBAAyB,kBAAkB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,mCAAmC,WAAW,kCAAkC;AACvF,OAAO;AACP;AACA;AACA,gBAAgB,qCAAqC,aAAa,uBAAuB;AACzF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA,yBAAyB,QAAQ;;AAEjC;AACA;;AAEA;AACA,2CAA2C,wCAAwC;;AAEnF,gBAAgB,mCAAmC,WAAW,kCAAkC;AAChG;AACA,kBAAkB,qCAAqC,aAAa,uBAAuB;AAC3F;AACA;AACA,cAAc,gEAAgE;;AAE9E,mBAAmB,6BAA6B;;AAEhD;AACA;AACA;;AAEA;;;;;;;AC5IA,OAAO,OAAO;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA,WAAW,2DAA2D;AACtE,uBAAuB,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,KAAK;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;;AAEA;AACA,wCAAwC,iBAAiB;;AAEzD,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,wCAAwC,UAAU,gBAAgB;AAClF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,wCAAwC;AAC7E;AACA,gBAAgB,wCAAwC,cAAc,gBAAgB;AACtF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;;AAEnC;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,WAAW;AACnC;;AAEA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC1SA;AACA;AACA;AACA;AACA;AACA,OAAO,0BAA0B;;AAEjC,yBAAyB;;AAEzB;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,kBAAkB;;AAEnD;AACA;AACA;AACA,SAAS,yCAAyC;AAClD,SAAS,iDAAiD;AAC1D,SAAS,4CAA4C;AACrD,SAAS,oEAAoE;AAC7E,SAAS,mCAAmC;AAC5C,SAAS,2DAA2D;AACpE,SAAS;AACT;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,SAAS,SAAS;AAClB;AACA,qCAAqC,6BAA6B;AAClE;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,WAAW,UAAU;AACrB;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,WAAW,YAAY;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,+BAA+B;;AAE3D,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA,0CAA0C,yBAAyB;AACnE,GAAG;;AAEH;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;;AAEA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;AC5IA,iC;;;;;;ACAA,oC;;;;;;ACAA,mC;;;;;;ACAA,0C;;;;;;ACAA,wC;;;;;;ACAA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iCAAiC,KAAK;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;;AAEA;AACA;;AAEA;AACA,0CAA0C,oBAAoB;AAC9D;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 14);\n","const { fork } = require('child_process');\nconst crypto = require('crypto');\nconst path = require('path');\nconst Promise = require('bluebird');\n\nconst maskTable = Object.freeze([\n  0x80, \n  0x40, \n  0x20,\n  0x10,\n  0x08,\n  0x04,\n  0x02,\n  0x01\n]);\n\nPromise.config({\n  // enable warnings\n  warnings: true,\n  // enable long stack traces\n  longStackTraces: true,\n  //enable cancellation\n  cancellation: true\n});\n\nconst sha256 = (content, digest = 'hex') => {\n  return crypto.createHash('sha256')\n    .update(content)\n    .digest(digest);\n};\n\n/**\n * @param {Array<string>} leaves  list of litemessage ids\n */\nconst calcMerkleRoot = (leaves) => {\n  if (leaves.length === 0) {\n    throw new Error('Cannot calcuate merkle root from 0 leaf.');\n  }\n  if (leaves.length % 2 === 1) {\n    leaves = [...leaves, leaves[leaves.length - 1]]\n  }\n  let innerNodes = [];\n  for (let i = 0; i < leaves.length; i += 2) {\n    innerNodes.push(sha256(`${leaves[i]}${leaves[i + 1]}`));\n  }\n  if (innerNodes.length === 1) {\n    return innerNodes[0];\n  }\n  return calcMerkleRoot(innerNodes);\n}\n\n/**\n * If verification passes, `true` will be returned.\n */\nconst verifyMerkleRoot = (merkleRoot, leaves) => {\n  return merkleRoot === calcMerkleRoot(leaves);\n}\n\n/**\n * @param {Buffer|string} buffer binary buffer or string in hex encoding\n */\nconst leadingZeroBits = (buffer) => {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer, 'hex');\n  }\n  let bits = 0;\n  let byteAt = 0;\n\n  for (; buffer[byteAt] === 0; byteAt++) {\n    bits += 8;\n  }\n  for (let bitAt = 0; bitAt < 8; bitAt++) {\n    if (buffer[byteAt] & maskTable[bitAt]) {\n      break;\n    }\n    bits += 1;\n  }\n\n  return bits;\n}\n\nconst mine = (content, difficulty) => \n  new Promise((resolve, reject, onCancel) => {\n    if (typeof difficulty !== 'number') { reject(new Error('Invalid difficulty.')); }\n    let cp = fork(path.join(__dirname, 'mine.js'), [content, difficulty]);\n\n    let timer = setTimeout(() => {\n      cp.removeAllListeners();\n      cp.kill('SIGTERM');\n      reject(new Error('Mining timeouts.'));\n\n      // disable timeout in production\n    }, 600000);\n\n    cp.on('message', (nonce) => {\n      clearTimeout(timer);\n      resolve(nonce);\n    });\n   \n    onCancel(() => {\n      clearTimeout(timer);\n      cp.removeAllListeners();\n      cp.kill('SIGTERM');\n    });\n  });\n\n/**\n * TODO validate timestamp, sig, pubKey\n * For timestamp, need to consider how long it takes to\n * populate the network.\n */\nconst verifyLitemsg = (litemessage) => {\n  if (!litemessage) { return false; }\n\n  let { ver, time, litemsg, sig, pubKey, hash } = litemessage;\n\n  if (typeof ver !== 'number') {\n    return false;\n  }\n  if (typeof time !== 'number') {\n    return false;\n  }\n  if (typeof litemsg !== 'string') {\n    return false;\n  }\n  if (hash !== sha256(`${ver}${time}${litemsg}${sig}${pubKey}`)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * TODO validate timestamp, bits (its value)\n * \n * Note that if you don't pass `prevBlock`, this func won't verify `height` (though\n * it still must be a positive number) and `prevBlock` (though it still must be \n * `undefined` when `height` is 0).\n * \n * When verifying genesis block (the first block), you shouldn't pass `prevBlock`\n * parameter.\n * \n * @param {*} block     the block to verify\n * @param {*} prevBlock (optional) previous block (not id), which the verified\n *                      block should be after immediately\n */\nconst verifyBlock = (block, prevBlock) => {\n  if (!block) { return false; }\n\n  let { ver, time, height, merkleRoot, bits, nonce, litemsgs } = block;\n\n  if (typeof ver !== 'number') {\n    return false;\n  }\n  if (typeof time !== 'number') {\n    return false;\n  }\n  if (typeof height !== 'number' || height < 0 || \n    (height === 0 && typeof block.prevBlock !== 'undefined') ||\n    (height !== 0 && typeof block.prevBlock === 'undefined')) {\n\n    return false;\n  }\n  if (!(litemsgs instanceof Array) || !litemsgs.length) {\n    return false;\n  }\n  if (typeof merkleRoot !== 'string' || !verifyMerkleRoot(merkleRoot, litemsgs.map(m => m.hash))) {\n    return false;\n  }\n  \n  /* bits, nonce, hash */\n  if (typeof bits !== 'number'|| typeof nonce !== 'number'\n    || nonce < 0 || typeof block.hash !== 'string') {\n    \n    return false;\n  }\n  let hash = sha256(`${ver}${time}${height}${block.prevBlock}${merkleRoot}${bits}${nonce}`);\n  if (hash !== block.hash || leadingZeroBits(hash) < bits) {\n    return false;\n  }\n\n  /* litemsgs */\n  for (let litemsg of litemsgs) {\n    if (!verifyLitemsg(litemsg)) { return false; }\n  }\n\n  /* height, prevBlock */\n  if (typeof prevBlock !== 'undefined') {\n    if (typeof block.prevBlock !== 'string' || prevBlock.hash !== block.prevBlock) {\n      return false;\n    }\n\n    if (prevBlock.height + 1 !== height) { return false; }\n  }\n  return true;\n};\n\n/**\n * Note that `subchain` start from elder blocks to newer blocks, which is a\n * block array.\n * \n * Parameter `prevBlock` should always be a valid block (NEVER pass un-verified\n * blocks received from peers). Or when the subchain starts at genesis block, \n * do not pass parameter `prevBlock` (leave it as `undefined`).\n */\nconst verifySubchain = (subchain, prevBlock) => {\n  for (let block of subchain) {\n    if (!verifyBlock(block, prevBlock)) {\n      return false;\n    }\n    prevBlock = block;\n  }\n  return true;\n};\n\nexports.sha256 = sha256;\nexports.calcMerkleRoot = calcMerkleRoot;\nexports.verifyMerkleRoot = verifyMerkleRoot;\nexports.leadingZeroBits = leadingZeroBits;\nexports.mine = mine;\nexports.verifyLitemsg = verifyLitemsg;\nexports.verifyBlock = verifyBlock;\nexports.verifySubchain = verifySubchain;\n","module.exports = require(\"events\");","const getRemoteAddress = (socket) => {\n  return socket._socket.remoteAddress.replace(/^.*:/, '');\n};\n\n/**\n * Note that a string will be returned.\n */\nconst getRemotePort = (socket) => {\n  return socket._socket.remotePort + '';\n};\n\nconst getSocketAddress = (socket) => {\n  return `${getRemoteAddress(socket)}:${getRemotePort(socket)}`;\n};\n\nexports.getRemoteAddress = getRemoteAddress;\nexports.getRemotePort = getRemotePort;\nexports.getSocketAddress = getSocketAddress;\n","/**\n * in ms\n */\nconst getCurTimestamp = (unit = 'ms') => {\n  if (unit === 'ms') {\n    return new Date().getTime();\n  } else if (unit === 's') {\n    return Math.round(new Date().getTime() / 1000);\n  } else {\n    throw new Error('Invalid unit: ' + unit + '.');\n  }\n}\n\nexports.getCurTimestamp = getCurTimestamp;\n","const path = require('path');\n\nconst isValidJson = (json) => {\n  if (typeof json !== 'string' || !json) {\n    return false;\n  }\n\n  try {\n    JSON.parse(json);\n    return true;\n  } catch (e) { }\n  return false;\n};\n\n/**\n * project's root path, of course this file cannot be moved around\n */\nconst getAbsRootPath = () => {\n  return path.join(__dirname, '../..');\n};\n\n/**\n * From 0 (inclusive) to `max` (exclusive).\n */\nconst randomInt = (max) => {\n  return Math.floor(Math.random() * Math.floor(max));\n};\n\n/**\n * Randomly pick `num` items from an array. Note that original array \n * won't be altered. And also the order of items won't be preserved \n * in the picked array.\n */\nconst pickItems = (array, num) => {\n  let copiedArray = [...array];\n  let picked = [];\n  num = Math.min(array.length, num);\n  for (let i = 0; i < num; i++) {\n    picked.push(...copiedArray.splice(randomInt(copiedArray.length), 1));\n  }\n  return picked;\n};\n\nconst parseChunk = (buffer) => {\n  if (buffer.length % 32) { throw new Error('Invalid chunk buffer.'); }\n\n  let hashes = [];\n  for (let i = 0; i < buffer.length; i += 32) {\n    hashes.push(buffer.slice(i, i + 32).toString('hex'));\n  }\n  return hashes;\n};\n\nexports.isValidJson = isValidJson;\nexports.getAbsRootPath = getAbsRootPath;\nexports.randomInt = randomInt;\nexports.pickItems = pickItems;\nexports.parseChunk = parseChunk;\n","module.exports = require(\"fs\");","module.exports = require(\"leveldown\");","module.exports = require(\"levelup\");","const EventEmitter = require('events');\nconst WSServer = require('./wss');\nconst Peer = require('./peer');\nconst uuidv1 = require('uuid/v1');\nconst { getSocketAddress } = require('./utils/network');\nconst { getCurTimestamp } = require('./utils/time');\n\n/**\n * Each Litenode will have a UUID automatically generated when start up. \n * Use this UUID as an application-level mechanism to identifing a node.\n * \n * TODO polish the close api (right now after closing, you can not use it anymore),\n *    and also levelup's close callback.\n * \n * #### Events\n * - `connection`\n * - `disconnection`\n * - `message`\n * - `message/${message_type}`\n * - all other events are handled by low level abstraction (you don't need \n * to worry about).\n */\nclass LiteNode extends EventEmitter {\n  /**\n   * A UUID will be automatically generated.\n   */\n  constructor(nodeType, { port, debug = true } = {}) {\n    super();\n    this.connectionHandler = this.connectionHandler.bind(this);\n    this.socketMessageHandler = this.socketMessageHandler.bind(this);\n    this.socketCloseHandler = this.socketCloseHandler.bind(this);\n\n    this.uuid = uuidv1();\n    this.nodeType = nodeType;\n    // map node's uuid to peer (Peer)\n    // all sockets from this SHOULD be alive\n    // so you MIGHTN'T need to worry about it\n    this.peers = {};\n\n    // used for debugging (view all protocol messages since start)\n    this.debug = debug;\n    this.messageLogs = [];\n\n    this.wss = new WSServer(this.uuid, this.nodeType, { port });\n    // when bound to an network interface\n    this.wss.on('listening', (port) => {\n      console.log(`${this.uuid}: Start listening on port ${port}.`);\n      if (this.debug) { console.log('Debug mode is enabled.'); }\n    });\n    // when new connection established\n    this.wss.on('connection', this.connectionHandler);\n  }\n\n  /**\n   * Create a proxy to intercept the `send` function call,\n   * mainly for debugging/logging.\n   */\n  createSocketProxy(socket, remoteUuid) {\n    const messageLogs = this.messageLogs;\n\n    const handler = {\n      get: (socket, propName) => {\n        if (propName !== 'send') { return socket[propName]; }\n        // return the wrapper function as a proxy\n        return function (data, options, callback) {\n          messageLogs.push({\n            peer: remoteUuid,\n            dir: 'outbound',\n            msg: JSON.parse(data),\n            time: getCurTimestamp('s')\n          });\n\n          return socket.send(data, options, callback);\n        };\n      }\n    };\n    // create socket proxy and return\n    return new Proxy(socket, handler);\n  }\n\n  /**\n   * Note that you cannot have more than one socket to a single URL.\n   * And also note that error could be thrown if url is invalid.\n   * Failure of connection will only cause some log (won't crash\n   * the application).\n   * \n   * Right now, there's no way to get notified when it fail to connect\n   * (such as because of timeout) except for a log mentioned before.\n   */\n  createConnection(url) {\n    return this.wss.createConnection(url);\n  }\n\n  /**\n   * @param {string} msg \n   * @param {Array<string>} exUuids \n   */\n  broadcast(msg, exUuids = []) {\n    let peers = Object.keys(this.peers)\n      .filter(uuid => !exUuids.includes(uuid))\n      .map(uuid => this.peers[uuid]);\n\n    for (let peer of peers) {\n      try {\n        peer.send(msg);\n      } catch (err) {\n        console.error(err);\n      }\n    }\n  }\n\n  /**\n   * @param {Object} jsonObj \n   * @param {Array<string>} exUuids \n   */\n  broadcastJson(jsonObj, exUuids) {\n    this.broadcast(JSON.stringify(jsonObj), exUuids);\n  }\n\n  /**\n   * Note that `remoteDaemonPort` and `remotePort` are string here.\n   */\n  connectionHandler(socket, incoming, remoteUuid, remoteDaemonPort, remoteNodeType) {\n    let socketAddress = getSocketAddress(socket);\n    if (incoming) {\n      console.log(`Accepted connection from ${remoteUuid || ''}@${socketAddress}.`);\n    } else {\n      console.log(`Established connection to ${remoteUuid || ''}@${socketAddress}.`);\n    }\n\n    socket.on('close', (code, reason) =>\n      this.socketCloseHandler(code, reason, socket, remoteUuid));\n    // a series of checking follows...\n    if (!remoteUuid) {\n      console.warn(`Established connection with a peer @${socketAddress} without UUID;\\n`\n        + `so, going to disconnect from it.`);\n      socket.close(undefined, 'NO_REMOTE_UUID');\n      return;\n    }\n    if (!remoteDaemonPort) {\n      console.warn(`Established connection with a peer @${socketAddress} without daemon port;\\n`\n        + `so, going to disconnect from it.`);\n      socket.close(undefined, 'NO_DAEMON_PORT');\n      return;\n    }\n    if (!remoteNodeType) {\n      console.warn(`Established connection with a peer @${socketAddress} without node type;\\n`\n        + `so, going to disconnect from it.`);\n      socket.close(undefined, 'NO_NODE_TYPE');\n      return;\n    }\n    if (this.peers.hasOwnProperty(remoteUuid)) {\n      console.warn(`Established connection with a connected peer (${remoteUuid}@${socketAddress});\\n`\n        + `so, going to disconnect from it.`);\n      socket.close(undefined, 'DOUBLE_CONNECT');\n      return;\n    }\n\n    // continue the process of connection establishment...\n\n    if (this.debug) {\n      socket = this.createSocketProxy(socket, remoteUuid);\n    }\n    let newPeer = new Peer(remoteUuid, socket, incoming, remoteDaemonPort, remoteNodeType);\n    this.peers[remoteUuid] = newPeer;\n    socket.on('message', (msg) => this.socketMessageHandler(msg, newPeer));\n    // notify listeners\n    this.emit('connection', newPeer);\n  }\n\n  socketMessageHandler(msg, peer) {\n    // notify listeners\n    this.emit('message', msg, peer);\n\n    let msgObj = null;\n    try { msgObj = JSON.parse(msg); } catch (e) {}\n    if (msgObj && msgObj['messageType']) {\n      // note that only logs valid procotol messages\n      this.messageLogs.push({\n        peer: peer.uuid,\n        dir: 'inbound',\n        msg: msgObj,\n        time: getCurTimestamp('s')\n      });\n\n      this.emit(`message/${msgObj['messageType']}`, msgObj, peer);\n    }\n  }\n\n  socketCloseHandler(code, reason, socket, remoteUuid) {\n    let peer = remoteUuid ? this.peers[remoteUuid] : undefined;\n    let socketAddress = getSocketAddress(socket);\n\n    if (peer && socket === peer.socket) {\n      console.log(`Disconnected from ${remoteUuid}@${socketAddress} (${code || 'N/A'} | ${reason || 'N/A'}).`);\n      delete this.peers[remoteUuid];\n      // notify listeners\n      this.emit('disconnection', peer);\n    } else {\n      console.log(`Disconnected from @${socketAddress} (${code || 'N/A'} | ${reason || 'N/A'}).`);\n    }\n  }\n\n  /**\n   * Close this node (both server and outgoing socket connections will\n   * be closed)\n   */\n  close(callback) {\n    this.wss.close(callback);\n  }\n}\n\nmodule.exports = LiteNode;\n","module.exports = require(\"url\");","const dns = require('dns');\nconst { URL } = require('url');\nconst { promisify } = require('util');\nconst P2PProtocolStore = require('./store');\nconst {\n  messageTypes, messageValidators, fetchPeers, returnPeers\n} = require('./messages');\nconst { pickItems } = require('../utils/common');\n\n// look up dns records\nconst lookup = promisify(dns.lookup);\n\n/**\n * A abstract peer-to-peer protocol. You should NOT bind this protocol directly to \n * an implementation of node client. Instead, you should extend this protocol.\n */\nclass P2PProtocol {\n  /**\n   * @param {*} node      full node, thin node, or...\n   * @param {*} nodeTypes node types to which a node will try to establish connection\n   */\n  constructor(node, nodeTypes, { minPeerNum = 8 } = {}) {\n    this.persistPeerUrls = this.persistPeerUrls.bind(this);\n    this.fetchPeersHandler = this.fetchPeersHandler.bind(this);\n    this.returnPeersHandler = this.returnPeersHandler.bind(this);\n\n    this.node = node;\n    this.litenode = node.litenode;\n    this.nodeTypes = nodeTypes;\n    this.minPeerNum = minPeerNum;\n    this.intervalTimers = [];\n    this.store = new P2PProtocolStore(node.db);\n\n    // register message handlers\n    this.litenode.on(`message/${messageTypes['fetchPeers']}`, this.fetchPeersHandler);\n    this.litenode.on(`message/${messageTypes['returnPeers']}`, this.returnPeersHandler);\n\n    this.connectToLastConnectedPeers();\n\n    // periodically fetch more peers of given node types\n    this.intervalTimers.push(\n      setInterval(() => {\n        if (this.node.peers(nodeTypes).length < minPeerNum) {\n          this.litenode.broadcastJson(fetchPeers({ nodeTypes }));\n        }\n      }, 60000)\n    );\n\n    // periodically persist peer urls\n    this.intervalTimers.push(\n      setInterval(this.persistPeerUrls, 120000)\n    );\n  }\n\n  async connectToLastConnectedPeers() {\n    try {\n      let initUrls = this.node.initPeerUrls;\n      // initial peer urls can be hostnames, so perform dns queries first\n      let addresses = await Promise.all(\n        initUrls.map(url => lookup(new URL(url).hostname, { family: 4 }))\n      );\n\n      initUrls = initUrls.map((url, i) => {\n        url = new URL(url);\n        url.hostname = addresses[i].address\n        return url.toString().replace(/\\/$/, '');\n      });\n\n      (await this.store.readCurPeerUrls())\n        .filter(url => !initUrls.includes(url))\n        .forEach(url => this.litenode.createConnection(url));\n\n    } catch (err) {\n      console.error(err);\n      process.exit(1);\n    }\n  }\n\n  async persistPeerUrls() {\n    try {\n      let peerUrls = this.node.peers(this.nodeTypes)\n        .map(peer => peer.url);\n      await this.store.writeCurPeerUrls(peerUrls);\n    } catch (err) {\n      console.error(err);\n    }\n  }\n\n  fetchPeersHandler({ messageType, ...payload }, peer) {\n    try {\n      // validate the received message\n      messageValidators[messageType](payload);\n      \n      let { nodeTypes, limit } = payload;\n      let connectedPeerUrls = this.node.peers(nodeTypes)\n        .map(peer => peer.url);\n      if (connectedPeerUrls.includes(peer.url)) {\n        connectedPeerUrls.splice(connectedPeerUrls.indexOf(peer.url), 1);\n      }\n      let peerUrls = pickItems(connectedPeerUrls, limit);\n      let resMsg = returnPeers({ nodeTypes, peerUrls });\n      peer.sendJson(resMsg);\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  returnPeersHandler({ messageType, ...payload }, peer) {\n    try {\n      // validate the received message\n      messageValidators[messageType](payload);\n      \n      let { nodeTypes, peerUrls } = payload;\n      let connectedPeerUrls = this.node.peers(nodeTypes)\n        .map(peer => peer.url);\n      peerUrls.filter(url => !connectedPeerUrls.includes(url))\n        .forEach(url => this.litenode.createConnection(url));\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  close() {\n    this.intervalTimers.forEach(t => clearInterval(t));\n  }\n}\n\nmodule.exports = P2PProtocol;\n","module.exports = require(\"path\");","const { sha256 } = require('../../utils/litecrypto');\n\n/**\n * Note for genesis block, its `height` must be 0, and `prevBlock` be `undefined`.\n * \n * @param {*} ver         version number (now hardcoded to 1, I don't have time :|)\n * @param {*} time        timestamp (unix time)\n * @param {*} height\n * @param {*} prevBlock   previous block's id\n * @param {*} merkleRoot  merkle root\n * @param {*} bits        difficulty\n * @param {*} nonce       nonce\n * @param {*} litemsgs    an array of litemessages (not ids)\n */\nconst createBlock = (ver, time, height, prevBlock, merkleRoot, bits, nonce, litemsgs) => {\n  let hash = undefined;\n  if (typeof nonce === 'number') {\n    // only calculate hash when `nonce` is given\n    hash = sha256(`${ver}${time}${height}${prevBlock}${merkleRoot}${bits}${nonce}`);\n  }\n  return { ver, time, height, prevBlock, merkleRoot, bits, nonce, litemsgs, hash };\n};\n\nmodule.exports = createBlock;\n","const messageTypes = Object.freeze({\n  getBlocks: 'lite/get_blocks',\n  inv: 'lite/inv',\n  getData: 'lite/get_data',\n  data: 'lite/data',\n\n  getPendingMsgs: 'lite/get_pending_msgs',\n\n  getHeaders: 'lite/get_headers',\n  headers: 'lite/headers'\n});\n\nconst getBlocks = ({ blockLocators }) => ({\n  messageType: messageTypes.getBlocks,\n  blockLocators\n});\n\ngetBlocks.validate = ({ blockLocators }) => {\n  if (!(blockLocators instanceof Array)) {\n    throw new Error('lite/: Invalid block locators.');\n  }\n};\n\n\n/**\n * both params are list of ids\n */\nconst inv = ({ blocks = [], litemsgs = [] }) => ({\n  messageType: messageTypes.inv,\n  blocks,\n  litemsgs\n});\n\ninv.validate = ({ blocks, litemsgs }) => {\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n  if (!(litemsgs instanceof Array)) {\n    throw new Error('lite/: Invalid lite messages.');\n  }\n};\n\n\n/**\n * both params are list of ids\n */\nconst getData = ({ blocks = [], litemsgs = [] }) => ({\n  messageType: messageTypes.getData,\n  blocks,\n  litemsgs\n});\n\ngetData.validate = ({ blocks, litemsgs }) => {\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n  if (!(litemsgs instanceof Array)) {\n    throw new Error('lite/: Invalid lite messages.');\n  }\n};\n\n\nconst data = ({ blocks = [], litemsgs = [] }) => ({\n  messageType: messageTypes.data,\n  blocks,\n  litemsgs\n});\n\ndata.validate = ({ blocks, litemsgs }) => {\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n  if (!(litemsgs instanceof Array)) {\n    throw new Error('lite/: Invalid lite messages.');\n  }\n};\n\n\nconst getPendingMsgs = () => ({\n  messageType: messageTypes.getPendingMsgs\n});\n\ngetPendingMsgs.validate = () => {\n  // nothing\n};\n\n\n// validators\nconst messageValidators = Object.freeze({\n  [messageTypes.getBlocks]: getBlocks.validate,\n  [messageTypes.inv]: inv.validate,\n  [messageTypes.getData]: getData.validate,\n  [messageTypes.data]: data.validate,\n  [messageTypes.getPendingMsgs]: getPendingMsgs.validate\n});\n\nexports.messageTypes = messageTypes;\nexports.messageValidators = messageValidators;\nexports.getBlocks = getBlocks;\nexports.inv = inv;\nexports.getData = getData;\nexports.data = data;\nexports.getPendingMsgs = getPendingMsgs;\n","if (BUILD_TARGET === 'node') {\n  // node (commonjs)\n\n  exports.ThinClient = require('./src/client/client');\n  exports.ThinClientProtocol = require('./src/client/protocol');\n\n  exports.createLitemsg = require('./src/liteprotocol/entities/litemsg');\n  exports.LiteProtocol = require('./src/liteprotocol/liteprotocol');\n  module.exports = exports =  { ...exports, ...require('./src/liteprotocol/messages') };\n\n  module.exports = exports = { ...exports, ...require('./src/utils/litecrypto') };\n  module.exports = exports = { ...exports, ...require('./src/utils/time') };\n  \n  exports.FullNode = require('./src/fullnode');\n  \n} else {\n  // browser (umd)\n\n\n}\n","const fs = require('fs');\nconst leveldown = require('leveldown');\nconst levelup = require('levelup');\nconst LiteNode = require('../litenode');\n\nconst nodeTypes = ['full', 'thin'];\nconst nodeType = 'thin';\n\nclass ThinClient {\n  constructor(protocolClass, dbPath, { port = 1113, initPeerUrls = [] } = {}) {\n    this.port = port;\n    port = typeof port === 'number' ? (port + '') : undefined;\n    this.initPeerUrls = [...initPeerUrls];\n\n    // initialize the db (level db)\n    this.initDb(dbPath);\n\n    // create underlying litenode\n    this.litenode = new LiteNode(nodeType, { port });\n\n    // load protocol\n    this.protocol = new protocolClass(this, nodeTypes);\n\n    // connect to initial peers\n    initPeerUrls.forEach(url => this.litenode.createConnection(url));\n\n    this.timer = setInterval(() => {\n      console.log(`Right now, there are ${this.peers().length} connected peers (full & thin).`);\n    }, 20000);\n  }\n\n  static get nodeType() {\n    return nodeType;\n  }\n\n  initDb(dbPath) {\n    if (fs.existsSync(dbPath) && fs.statSync(dbPath).isDirectory()) {\n      console.log('Using existing LevelDB directory.');\n    } else {\n      console.log('A new LevelDB directory will be created.');\n    }\n    this.db = levelup(leveldown(dbPath));\n  }\n\n  /**\n   * @param {string|Array<string>} nodeType the node types (pass `*` for matching all types)\n   */\n  peers(nodeTypes = '*') {\n    if (typeof nodeTypes === 'string' && nodeTypes !== '*') {\n      nodeTypes = [nodeTypes];\n    }\n\n    let peers = this.litenode ? Object.values(this.litenode.peers) : [];\n    return peers.filter(peer => nodeTypes === '*' || nodeTypes.includes(peer.nodeType));\n  }\n\n  close(callback) {\n    clearInterval(this.timer);\n    this.litenode.close(callback);\n    this.db.close();\n  }\n}\n\nmodule.exports = ThinClient;\n","const EventEmitter = require('events');\nconst WebSocket = require('ws');\nconst { URL } = require('url');\nconst { getSocketAddress } = require('./utils/network');\n\n// remote end's uuid\nconst uuidHeaderName = 'x-litemessage-uuid';\n// remote end's listening (daemon) port\nconst portHeaderName = 'x-litemessage-port';\n// remote end's node type\nconst typeHeaderName = 'x-litemessage-type';\n\nconst socketEvents = [\n  'close', 'error', 'message', 'open', 'ping',\n  'unexpected-response', 'upgrade'\n];\n\n/**\n * Provide abstraction for underlaying transportation protocol. It behaves \n * both like a server and a client - it will connect to several clients, \n * and also several servers (P2P network).\n * \n * The P2P network is a directed graph with bidirectional communication channels.\n * \n * TODO close reason doesn't work\n * TODO investigate even emitter memory leak\n * TODO docker delievery\n * \n * ##### Events\n * - `listening` (port: string) - when the underlying ws server binds successfully\n * - `connection` (socket, incoming, remoteUuid, remoteDaemonPort, remoteNodeType)\n * \n * For all other events, use the underlying web socket object.\n */\nclass WSServer extends EventEmitter {\n  constructor(uuid, nodeType, { port = 1113 } = {}) {\n    super();\n    this.connectionHandler = this.connectionHandler.bind(this);\n    \n    this.uuid = uuid;\n    this.nodeType = nodeType;\n    this.port = port + '';\n    // used in handshake (for initiator to send)\n    this.headers = {\n      [uuidHeaderName]: this.uuid,\n      [portHeaderName]: this.port,\n      [typeHeaderName]: this.nodeType\n    };\n    // map remote socket addresses (ip:port) to sockets\n    this.servers = {};\n    \n    // create underlaying server and listen\n    this.wss = new WebSocket.Server({ port });\n    // when bound to an network interface\n    this.wss.on('listening', () => this.emit('listening', port));\n    // before sending upgrade response\n    this.wss.on('headers', (headers, req) => {\n      // add uuid header to upgrade response\n      headers.push([`${uuidHeaderName}: ${this.uuid}`]);\n      headers.push([`${portHeaderName}: ${this.port}`]);\n      headers.push([`${typeHeaderName}: ${this.nodeType}`]);\n    });\n    // when receiving incoming connection\n    this.wss.on('connection', (socket, req) => {\n      let remoteUuid = req.headers[uuidHeaderName];\n      let remoteDaemonPort = req.headers[portHeaderName];\n      let remoteNodeType = req.headers[typeHeaderName];\n      this.connectionHandler(socket, true, remoteUuid, remoteDaemonPort, remoteNodeType);\n    });\n    this.wss.on('error', console.log);\n\n    // set up heartbeats\n    this.timer = setInterval(this.genHeartbeat(), 60000);\n  }\n\n  /**\n   * Close this node (both server and outgoing socket connections will\n   * be closed)\n   */\n  close(callback) {\n    clearInterval(this.timer);\n    this.wss.close(callback);\n  }\n\n  /**\n   * Note that you cannot have more than one socket to a single URL.\n   * And also note that error could be thrown if url is invalid.\n   * Failure of connection will only cause some log (won't crash\n   * the application).\n   * \n   * Right now, there's no way to get notified when it fail to connect\n   * (such as because of timeout) except for a log mentioned before.\n   */\n  createConnection(url) {\n    let socketAddress = null;\n    let remoteDaemonPort = null;\n    try {\n      ({ host: socketAddress, port: remoteDaemonPort } = new URL(url));\n      if (!socketAddress || !remoteDaemonPort.match(/^\\d+$/)) { throw new Error(); }\n    } catch (err) {\n      throw new Error(`Wrong url (${url}) to connect.`);\n    }\n\n    let prevSocket = this.servers[socketAddress];\n    if (prevSocket && this.socketAlive(prevSocket)) {\n      console.warn(`Tried to connect to same url (${url}) twice. Operation aborted.`);\n      return;\n    }\n\n    let remoteUuid = undefined;\n    let remoteNodeType = undefined;\n    let socket = new WebSocket(url, { headers: this.headers, handshakeTimeout: 10000 });\n    socket.on('upgrade', resp => {\n      // read uuid and node type from upgrade response header\n      remoteUuid = resp.headers[uuidHeaderName];\n      remoteNodeType = resp.headers[typeHeaderName];\n    });\n    socket.on('open', () => {\n      let prevSocket = this.servers[socketAddress];\n      if (prevSocket && this.socketAlive(prevSocket)) {\n        // TODO investigate memory leak\n        socket.on('close', () => this.unregisterSocketListeners(socket));\n        socket.close(undefined, 'DOUBLE_CONNECT');\n        return;\n      }\n      socket.removeAllListeners('error');\n      this.connectionHandler(socket, false, remoteUuid, remoteDaemonPort, remoteNodeType);\n      this.servers[socketAddress] = socket;\n    });\n    socket.on('error', (err) =>\n      console.log(`Unable to establish connect to ${url}. Details:\\n${err}.`));\n  }\n\n  genHeartbeat() {\n    let noop = () => {};\n    return () => {\n      for (let socket of [...this.wss.clients, ...Object.values(this.servers)]) {\n        if (this.socketAbnormal(socket)) {\n          socket.terminate();\n        }\n        // set socket `alive` to false, later pong response\n        // from client will recover `alive` from false to true\n        socket.alive = false;\n        socket.ping(noop);\n      }\n    }\n  }\n\n  /**\n   * @param {*} socket                  the underlaying socket\n   * @param {boolean} incoming          whether the connection is incoming\n   * @param {string} remoteUuid         remote peer's uuid\n   * @param {string} remoteDaemonPort   remote peer's litenode deamon port\n   */\n  connectionHandler(socket, incoming, remoteUuid, remoteDaemonPort, remoteNodeType) {\n    let socketAddress = getSocketAddress(socket);\n    socket.alive = true;\n    socket.on('message', () => socket.alive = true);\n    socket.on('pong', () => socket.alive = true);\n    socket.on('close', () => {\n      socket.alive = false;\n      this.unregisterSocketListeners(socket);\n      if (socket === this.servers[socketAddress]) {\n        delete this.servers[socketAddress];\n      }\n    });\n    socket.on('error', err => {\n      console.log(err);\n      socket.terminate();\n    });\n    // notify subscribers\n    this.emit('connection', socket, incoming, remoteUuid, remoteDaemonPort, remoteNodeType);\n  }\n\n  socketAbnormal(socket) {\n    return !socket.alive && socket.readyState === WebSocket.OPEN;\n  }\n\n  socketAlive(socket) {\n    return socket.readyState === WebSocket.OPEN;\n  }\n\n  unregisterSocketListeners(socket) {\n    socketEvents.forEach(e => socket.removeAllListeners(e));\n  }\n}\n\nmodule.exports = WSServer;\n","module.exports = require(\"ws\");","const { getRemoteAddress } = require('./utils/network');\n\nclass Peer {\n  /**\n   * @param {string} uuid             peer's uuid\n   * @param {*} socket                network socket to the peer\n   * @param {boolean} incoming        whehter the connection is incoming\n   * @param {string} daemonPort       peer's daemon port\n   * @param {string} nodeType         peer's node type\n   */\n  constructor(uuid, socket, incoming, daemonPort, nodeType) {\n    this.uuid = uuid;\n    this.socket = socket;\n    this.incoming = incoming;\n    this.daemonPort = daemonPort;\n    this.nodeType = nodeType;\n    this.url = `ws://${getRemoteAddress(socket)}:${daemonPort}`;\n  }\n\n  /**\n   * Note that error might be thrown, such as when trying to \n   * send data through closed connection (very rare though - the\n   * underlaying litenode will take care of that).\n   * \n   * @param {string} message to send\n   */\n  send(msg) {\n    this.socket.send(msg);\n  }\n\n  /**\n   * Note that error might be thrown, such as when trying to \n   * send data through closed connection (very rare though - the\n   * underlaying litenode will take care of that).\n   * \n   * @param {Object} jsonObj object to send\n   */\n  sendJson(jsonObj) {\n    this.send(JSON.stringify(jsonObj));\n  }\n\n  toString() {\n    return `${this.nodeType} - ${this.url}`;\n  }\n}\n\nmodule.exports = Peer;\n","module.exports = require(\"uuid/v1\");","const P2PProtocol = require('../p2pprotocol/p2protocol');\n\n/**\n * TODO later might change to extend liteprotocol\n */\nconst protocolClass = class extends P2PProtocol {\n  constructor(node, nodeTypes, { minPeerNum = 8 } = {}) {\n    super(node, nodeTypes, { minPeerNum });\n  }\n};\n\nmodule.exports = protocolClass;\n","module.exports = require(\"dns\");","module.exports = require(\"util\");","const prefix = 'p2p/';\n\nconst genKey = key => prefix + key;\n\nclass P2PProtocolStore {\n  constructor(db) {\n    this.db = db;\n  }\n\n  /**\n   * Flush current connected peers' URLs into DB. \n   * Note that you should only provide peers with \n   * desired `nodeType`s.\n   */\n  async writeCurPeerUrls(peerUrls) {\n    let data = JSON.stringify(peerUrls);\n    return this.db.put(genKey('cur_peer_urls'), data);\n  }\n\n  async readCurPeerUrls() {\n    try {\n      let buf = await this.db.get(genKey('cur_peer_urls'));\n      return JSON.parse(buf.toString());\n    } catch (err) {\n      if (err.notFound) { return []; }\n      throw err;\n    }\n  }\n}\n\nmodule.exports = P2PProtocolStore;\n","// message type constants\nconst messageTypes = Object.freeze({\n  fetchPeers: 'p2p/fetch_peers',\n  returnPeers: 'p2p/return_peers'\n});\n\n\n/**\n * \n */\nconst fetchPeers = ({ nodeTypes, limit = 20 } = {}) => ({\n  messageType: messageTypes.fetchPeers, \n  nodeTypes, \n  limit\n});\n\nfetchPeers.validate = ({ nodeTypes, limit }) => {\n  if (!(nodeTypes instanceof Array) || nodeTypes.length === 0) {\n    throw new Error('p2p/: Invalid message, field nodeTypes.');\n  }\n  if (typeof limit !== 'number' || limit <= 0) {\n    throw new Error('p2p/: Invalid message, field limit.');\n  }\n};\n\n\n/**\n * \n */\nconst returnPeers = ({ nodeTypes, peerUrls = [] } = {}) => ({\n  messageType: messageTypes.returnPeers, \n  nodeTypes, \n  peerUrls\n});\n\nreturnPeers.validate = ({ nodeTypes, peerUrls }) => {\n  if (!(nodeTypes instanceof Array) || nodeTypes.length === 0) {\n    throw new Error('p2p/: Invalid message, field nodeTypes.');\n  }\n  if (!(peerUrls instanceof Array)) {\n    throw new Error('p2p/: Invalid message, field peerUrls.');\n  }\n};\n\n\n// validators\nconst messageValidators = Object.freeze({\n  [messageTypes.fetchPeers]: fetchPeers.validate,\n  [messageTypes.returnPeers]: returnPeers.validate\n});\n\n\nexports.messageTypes = messageTypes;\nexports.messageValidators = messageValidators;\nexports.fetchPeers = fetchPeers;\nexports.returnPeers = returnPeers;\n","const { sha256 } = require('../../utils/litecrypto');\n\n/**\n * @param {string} ver      version number (now hardcoded to 1, I don't have time :|)\n * @param {int} time        timestamp (unix time)\n * @param {string} litemsg  litemessage itself\n * @param {string} sig      signature\n * @param {string} pubKey   public key\n */\nconst createLitemsg = (ver, time, litemsg, sig, pubKey) => {\n  let hash = sha256(`${ver}${time}${litemsg}${sig}${pubKey}`);\n  return { ver, time, litemsg, sig, pubKey, hash };\n};\n\nmodule.exports = createLitemsg;\n","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"bluebird\");","const P2PProtocol = require('../p2pprotocol/p2protocol');\nconst LiteProtocolStore = require('./store');\nconst Miner = require('./miner');\nconst Blockchain = require('../utils/blockchain');\nconst createRestServer = require('./rest');\nconst createBlock = require('./entities/block');\nconst {\n  messageTypes, messageValidators, getBlocks, \n  inv, getData, data, getPendingMsgs\n} = require('./messages');\nconst {\n  verifyBlock, verifyLitemsg, calcMerkleRoot, verifySubchain\n} = require('../utils/litecrypto');\nconst { pickItems } = require('../utils/common');\nconst { getCurTimestamp } = require('../utils/time');\n\nconst ver = 1;\nconst bits = 22;\nconst blockLimit = 2048;\n\nclass LiteProtocol extends P2PProtocol {\n  static get ver() {\n    return ver;\n  }\n\n  constructor(node, nodeTypes, { minPeerNum = 8 } = {}) {\n    super(node, nodeTypes, { minPeerNum });\n    this.getBlocksHandler = this.getBlocksHandler.bind(this);\n    this.invHandler = this.invHandler.bind(this);\n    this.getDataHandler = this.getDataHandler.bind(this);\n    this.dataHandler = this.dataHandler.bind(this);\n    this.getPendingMsgsHandler = this.getPendingMsgsHandler.bind(this);\n    this.connectionHandler = this.connectionHandler.bind(this);\n\n    this.liteStore = new LiteProtocolStore(node.db);\n    // a blockchain manager\n    this.blockchain = new Blockchain(this.liteStore);\n    this.miner = new Miner();\n    // map litemessage id to litemessage itself (pending litemessages)\n    this.litemsgPool = {};\n\n    // wait for blockchain initializing itself\n    this.blockchain.on('ready', () => { this.init() });\n\n    this.blockchain.on('error', err => {\n      console.error(err);\n      process.exit(1);\n    });\n  }\n\n  init() {\n    // register message/connection handlers\n    this.litenode.on(`message/${messageTypes.getBlocks}`, this.getBlocksHandler);\n    this.litenode.on(`message/${messageTypes.inv}`, this.invHandler);\n    this.litenode.on(`message/${messageTypes.getData}`, this.getDataHandler);\n    this.litenode.on(`message/${messageTypes.data}`, this.dataHandler);\n    this.litenode.on(`message/${messageTypes.getPendingMsgs}`, this.getPendingMsgsHandler);\n    this.litenode.on('connection', this.connectionHandler);\n\n    // create and run rest server\n    createRestServer(this).listen(this.node.port + 1);\n\n    // some schedule tasks (interval timers)\n    this.timers = [];\n\n    // schedule mining\n    this.timers.push(\n      setInterval(async () => {\n        if (!this.miner.mining && Object.entries(this.litemsgPool).length) {\n          this.mineNextBlock();\n        }\n\n      }, 1000)\n    );\n\n    // schedule getting pending messages\n    this.timers.push(\n      setInterval(() => {\n        if (Object.entries(this.litemsgPool).length > 0) { return; }\n\n        try {\n          pickItems(this.node.peers('full'), 8)\n            .forEach(peer => peer.sendJson(getPendingMsgs()))\n        } catch (err) { console.warn(err); }\n\n      }, 30000)\n    );\n  }\n\n  async getNextBlock() {\n    let time = getCurTimestamp();\n    let litemsgs = pickItems(Object.values(this.litemsgPool), blockLimit);\n    let merkleRoot = calcMerkleRoot(litemsgs.map(m => m.hash));\n    let { \n      height = -1, hash: prevBlock = undefined \n    } = await this.blockchain.getHeadBlock() || {};\n    height += 1;\n    \n    return createBlock(ver, time, height, prevBlock, merkleRoot, bits, undefined, litemsgs);\n  }\n\n  async mineNextBlock() {\n    let block = await this.getNextBlock();\n    block = await this.miner.mine(block);\n    let headBlockId = this.blockchain.getHeadBlockIdSync();\n\n    if (!headBlockId || block.prevBlock === headBlockId) {\n      let now = getCurTimestamp();\n      let timeTaken = Math.round((now - block.time) / 1000);\n      console.log(`Successfully mined a new block (${timeTaken} s): ${block.hash}.`);\n\n      // append the mined block to blockchain\n      this.blockchain.append(block);\n\n      // remove from pending message pool\n      for (let litemsg of block.litemsgs) {\n        delete this.litemsgPool[litemsg.hash];\n      }\n\n      // broadcast to peers\n      this.litenode.broadcastJson(inv({ blocks: [block.hash] }));\n    }\n  }\n\n  /**\n   * After receiving blocks from a peer and verifying them, call this\n   * func to remove litemessages (if any) which exist in these blocks\n   * before appending them to the blockchain.\n   * \n   * @param {*} blocks blocks (already verified) received from a peer\n   */\n  cleanPoolAndRestartMining(blocks) {\n    for (let block of blocks) {\n      for (let litemsg of block.litemsgs) {\n        delete this.litemsgPool[litemsg.hash];\n      }\n    }\n\n    if (Object.entries(this.litemsgPool).length) {\n      this.mineNextBlock();\n    }\n  }\n\n  inLitemsgPool(litemsgId) {\n    return !!this.litemsgPool[litemsgId];\n  }\n\n  /**\n   * If the given litemessage id is in LevelDB's litemessage index\n   * or it's in the pending pool, the return value will be `true`.\n   */\n  async hasLitemsg(litemsgId) {\n    return (await this.liteStore.hasLitemsg(litemsgId))\n      || this.inLitemsgPool(litemsgId);\n  }\n\n  // async hasBlock(blockId) {\n  //   // TODO\n  // }\n\n  async getBlocksHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { blockLocators } = payload;\n      let forkedBranch = this.blockchain.getForkedBranchSync(blockLocators);\n\n      if (forkedBranch.length) {\n        // send response based on received locators\n        peer.sendJson(inv({ blocks: forkedBranch }));\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async invHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { blocks, litemsgs } = payload;\n      let blocksToGet = [];\n      let litemsgsToGet = [];\n\n      // filter out blocks already have \n      // blocks off main branch also as being haven\n      for (let blockId of blocks) {\n        if (!(await this.blockchain.hasBlock(blockId, false))) {\n          blocksToGet.push(blockId);\n        }\n      }\n\n      // filter out litemessages already have\n      for (let litemsgId of litemsgs) {\n        if (!(await this.hasLitemsg(litemsgId))) {\n          litemsgsToGet.push(litemsgId);\n        }\n      }\n\n      if (blocksToGet.length || litemsgsToGet.length) {\n        // send response\n        peer.sendJson(\n          getData({ blocks: blocksToGet, litemsgs: litemsgsToGet })\n        );\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async getDataHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { blocks, litemsgs } = payload;\n      let respBlocks = null;\n      let respLitemsgs = [];\n\n      // give blocks no matter which branch they are on\n      respBlocks = await Promise.all(\n        blocks.map(blockId => this.blockchain.getBlock(blockId))\n      );\n      respBlocks = respBlocks.filter(block => typeof block !== 'undefined');\n\n      for (let litemsgId of litemsgs) {\n        // note only return litemessages from pool for `getData`\n        let litemsg = this.litemsgPool[litemsgId];\n        if (litemsg) { respLitemsgs.push(litemsg); }\n      }\n\n      if (respBlocks.length || respLitemsgs.length) {\n        // send response\n        peer.sendJson(\n          data({ blocks: respBlocks, litemsgs: respLitemsgs })\n        );\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  /**\n   * TODO sync pool and restart mining?\n   */\n  async dataHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { blocks, litemsgs } = payload;\n      let relayBlocks = []; // always 0 or 1 element\n      let relayLitemsgs = [];\n\n      // filter out invalid blocks and litemessages\n      blocks = blocks.filter(block => verifyBlock(block));\n      blocks.sort((a, b) => a.height - b.height);\n      litemsgs = litemsgs.filter(litemsg => verifyLitemsg(litemsg));\n\n      let headBlockId = this.blockchain.getHeadBlockIdSync();\n\n      if (blocks.length && blocks[blocks.length - 1].height > this.blockchain.getCurHeightSync()) {\n        if (blocks.length === 1) {\n          let block = blocks[0];\n\n          if (block.prevBlock === headBlockId) {\n            this.cleanPoolAndRestartMining(blocks);\n            this.blockchain.append(block);\n            relayBlocks.push(block);\n          } else {\n            let blockLocators = this.blockchain.getLocatorsSync();\n            peer.sendJson(getBlocks({ blockLocators }));\n          }\n        } else {\n          // Note that `prevBlockId` and `prevBlock` down below refer to same block.\n          // Later, they will be used for traversing backward along the blockchain.\n          let prevBlockId = blocks[0].prevBlock;\n          let prevBlock = prevBlockId ? \n            (await this.blockchain.getBlock(prevBlockId)) : \n            undefined;\n\n          if (verifySubchain(blocks, prevBlock)) {\n            // For efficiency, node doesn't fetch blocks on forked branch which it already \n            // has. The `litemsg_${litemsg_id}` of these mentioned blocks might be records\n            // on the main branch (before appending). So here, suppose the previous\n            // block of appended blocks is not on main branch, we need to extend from\n            // the appended blocks backwards to until a block which is on the main \n            // branch, or until the genesis block (of the forked branch), whichever reaches\n            // first. And then rewrite all `litemsg_${litemsg_id}` records so that all \n            // litemessages are correctly indexed after switching to another branch.\n\n            let extendedBlocks = [];\n\n            while (prevBlockId && !this.blockchain.onMainBranchSync(prevBlockId)\n              && headBlockId === this.blockchain.getHeadBlockIdSync()) {\n\n              extendedBlocks.unshift(prevBlock);\n\n              prevBlockId = prevBlock.prevBlock;\n              prevBlock = prevBlockId ?\n                (await this.blockchain.getBlock(prevBlockId)) :\n                undefined;\n            }\n\n            if (headBlockId === this.blockchain.getHeadBlockIdSync()) {\n              this.cleanPoolAndRestartMining(blocks);\n              // switch the blockchain to another branch\n              this.blockchain.appendAt([...extendedBlocks, ...blocks]);\n            }\n          }\n        }\n      }\n\n      // process received litemessages\n      for (let litemsg of litemsgs) {\n        if (await this.hasLitemsg(litemsg.hash)) { continue; }\n\n        relayLitemsgs.push(litemsg.hash);\n        this.litemsgPool[litemsg.hash] = litemsg;\n      }\n\n      if (relayBlocks.length || relayLitemsgs.length) {\n        // relay (broadcast) data messaage\n        this.litenode.broadcastJson(\n          inv({ blocks: relayBlocks, litemsgs: relayLitemsgs }),\n          [peer.uuid]\n        );\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  getPendingMsgsHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let litemsgs = Object.keys(this.litemsgPool);\n\n      if (litemsgs.length) {\n        // send response\n        peer.sendJson(inv({ litemsgs }));\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  connectionHandler(peer) {\n    if (peer.nodeType === 'full' && this.node.peers('full').length === 1) {\n      let blockLocators = this.blockchain.getLocatorsSync();\n      peer.sendJson(getBlocks({ blockLocators }));\n    }\n  }\n\n  close() {\n    for (let timer of this.timers) {\n      clearInterval(timer);\n    }\n    super.close();\n  }\n}\n\nmodule.exports = LiteProtocol;\n","const prefix = 'lite/';\n\nconst genKey = key => prefix + key;\n\nclass LiteProtocolStore {\n  constructor(db) {\n    this.db = db;\n  }\n\n  static get genKey() {\n    return genKey;\n  }\n\n  // async writeHeadBlock(blockId) {\n  //   return this.db.put(genKey('head_block'), blockId);\n  // }\n\n  /**\n   * Note that we don't index litemessage's content, which is part of a block.\n   * So in order to get the content of a litemessage, you must get the the block\n   * where the given litemessage resides first.\n   * \n   * This function return the block id (no matter the block in the main branch or\n   * not) where the given litemessage resides, or undefined if we don't have the\n   * litemessage in any block.\n   */\n  async readLitemsg(litemsgId) {\n    try {\n      let buf = await this.db.get(genKey(`litemsg_${litemsgId}`));\n      return buf.toString();\n\n    } catch (err) {\n      if (err.notFound) { return undefined; }\n      throw err;\n    }\n  }\n\n  /**\n   * TODO might change this: we don't need to have index for litemessages?\n   * might just litemessage's location index (in which block).\n   */\n  // async writeLitemsg(litemsg) {\n  //   if (typeof litemsg.hash !== 'string') {\n  //     throw new Error('Invalid litemessage hash.');\n  //   }\n  //   return this.db.put(genKey(`litemsg_${litemsg.hash}`), litemsg);\n  // }\n\n  async hasLitemsg(litemsgId) {\n    return (await this.readLitemsg(litemsgId)) !== undefined;\n  }\n\n  // following is block-related ...\n\n  /**\n   * Return the head block's **id** (or undefined when there's no\n   * block in the blockchain)\n   */\n  async readHeadBlock() {\n    try {\n      let buf = await this.db.get(genKey('head_block'));\n      return buf.toString();\n    } catch (err) {\n      if (err.notFound) { return undefined; }\n      throw err;\n    }\n  }\n\n  // async writeBlock(block) {\n  //   if (typeof block.hash !== 'string') {\n  //     throw new Error('Invalid block hash.');\n  //   }\n  //   return this.db.put(genKey(`block_${block.hash}`), block);\n  // }\n\n  /**\n   * Return the whole block specified by the given block id.\n   * If block doesn't exist, `undefined` will be returned.\n   */\n  async readBlock(blockId) {\n    try {\n      let buf = await this.db.get(genKey(`block_${blockId}`));\n      return JSON.parse(buf.toString());\n      \n    } catch (err) {\n      if (err.notFound) { return undefined; }\n      throw err;\n    }\n  }\n\n  /**\n   * Append one more block on top of the current head block.\n   */\n  async appendBlock(block, batchOps) {\n    if (typeof block.hash !== 'string') {\n      throw new Error('Invalid block hash.');\n    }\n\n    let ops = [\n      { type: 'put', key: genKey(`block_${block.hash}`), value: JSON.stringify(block) },\n      { type: 'put', key: genKey('head_block'), value: block.hash }\n    ];\n    for (let litemsg of block.litemsgs) {\n      ops.push({ type: 'put', key: genKey(`litemsg_${litemsg.hash}`), value: block.hash });\n    }\n    if (batchOps) {\n      ops = [...ops, ...batchOps];\n    }\n\n    return this.db.batch(ops);\n  }\n\n  /**\n   * Sometimes forks could happen. Call this to switch to\n   * another fork.\n   * \n   * @param {*} blocks  blocks from another branch to switch\n   */\n  async appendBlocksAt(blocks, batchOps) {\n    if (!blocks.length) { return; }\n\n    let headBlock = blocks[blocks.length - 1];\n    let ops = [];\n\n    for (let block of blocks) {\n      if (typeof block.hash !== 'string') { throw new Error('Invalid block hash.'); }\n\n      ops.push({ type: 'put', key: genKey(`block_${block.hash}`), value: JSON.stringify(block) });\n      for (let litemsg of block.litemsgs) {\n        ops.push({ type: 'put', key: genKey(`litemsg_${litemsg.hash}`), value: block.hash });\n      }\n    }\n    ops.push({ type: 'put', key: genKey('head_block'), value: headBlock.hash });\n\n    if (batchOps) { ops = [...ops, ...batchOps]; }\n\n    return this.db.batch(ops);\n  }\n}\n\nmodule.exports = LiteProtocolStore;\n","const { mine } = require('../utils/litecrypto');\nconst createBlock = require('./entities/block');\n\n/**\n * mining manager : )\n */\nclass Miner {\n  /**\n   * Use `mine` down below; it has easier interface.\n   * \n   * Start mining. If at the point you call this function,\n   * a mining is going on, that mining will be canceled\n   * automatically (right now doesn't support concurrent\n   * mining).\n   * \n   * Note that if the mining is canceled, it won't trigger\n   * `resolve` or `reject` of the returned promise.\n   */\n  calc(content, bits) {\n    if (this.mining) { this.cancel(); }\n    this.mining = mine(content, bits);\n    return this.mining\n      .then(nonce => {\n        this.mining = null;\n        return nonce;\n      })\n      .catch(err => {\n        this.mining = null;\n        throw err;\n      });\n  }\n\n  /**\n   * Note that it won't change the orginal block, but return a new\n   * successfully mined block.\n   * \n   * @param {*} block \n   */\n  mine(block) {\n    const { ver, time, height, prevBlock, merkleRoot, bits, litemsgs } = block;\n    const content = `${ver}${time}${height}${prevBlock}${merkleRoot}${bits}`;\n    return this.calc(content, bits)\n      .then(nonce => \n        createBlock(ver, time, height, prevBlock, merkleRoot, bits, nonce, litemsgs));\n  }\n\n  cancel() {\n    if (this.mining) {\n      this.mining.cancel();\n      this.mining = null;\n    }\n  }\n}\n\nmodule.exports = Miner;\n","const EventEmitter = require('events');\n\n/**\n * A chunk is a fixed number of consecutive blocks (only block id) grouped\n * together stored in LevelDB in binary format (not in hex encode), mainly\n * for efficiency.\n * \n * NOTE that once a block is stored in LevelDB, you should NEVER change this\n * constant down below.\n */\nconst chunkSize = 4;\n\n/**\n * This is a very low level abstraction of a blockchain, which needs to be \n * injected with an store (LevelDB) interface implementation for interacting\n * with LevelDB. Take `LiteProtocol` as an example.\n * \n * This blockchain abstraction here is (should) be protocol-agnostic.\n * \n * Once assumption using this blockchain abstraction here is that you MUST \n * always only persist valid blocks (it doesn't have to be in the main branch \n * in the long run, but it must be a valid block). And you append elder blocks \n * and then newer blocks to the blockchain, either one by one, or in a batch.\n * In other words, you MUST always append a block after all its predecessor blocks\n * have been persisted.\n * \n * NOTE that both chunk and height (length of blockchain) start at index 0.\n */\nclass Blockchain extends EventEmitter {\n  constructor(store) {\n    super();\n    this.store = store;\n    this.db = store.db;\n    this.genKey = store.constructor.genKey;\n    \n    // an array of block ids (in hex encoding)\n    this.blockchain = null;\n    this._ready = false;\n\n    this.init();\n  }\n\n  get ready() {\n    return this._ready;\n  }\n\n  async init() {\n    try {\n      let height = await this.getCurHeight() + 1;\n      let numOfChunks = Math.floor(height / chunkSize);\n      let numOfBlocks = height % chunkSize;\n\n      let chunks = await Promise.all(\n        Array.from(Array(numOfChunks).keys()) // generate a number sequence\n          .map(num => this._getChunk(num))\n      );\n      // flatten chunks\n      chunks = [].concat.apply([], chunks);\n\n      let blocks = [];\n      let prevBlockId = null;\n      for (let i = 0; i < numOfBlocks; i++) {\n        let block = await (\n          i === 0 ? this.getHeadBlock() : this.getBlock(prevBlockId)\n        );\n\n        prevBlockId = block.prevBlock;\n        blocks.unshift(block.hash);\n      }\n\n      this.blockchain = [...chunks, ...blocks];\n      this._ready = true;\n      this.emit('ready');\n\n    } catch (err) {\n      this.emit('error', err);\n    }\n  }\n\n  /**\n   * Inside a chunk, the order is from elder blocks to newer blocks.\n   * Note that if you're trying to get a non-existent chunk, an error\n   * will be thrown.\n   */\n  async _getChunk(serialNum) {\n    let buf = await this.db.get(this.genKey(`chunk_${serialNum}`));\n    let chunk = [];\n\n    // just be cautious\n    if (buf.length !== chunkSize * 32) { process.exit(1); }\n\n    for (let i = 0; i < buf.length; i += 32) {\n      chunk.push(buf.slice(i, i + 32).toString('hex'));\n    }\n    return chunk;\n  }\n\n  /**\n   * Append next block on top of current head block on the blockchain.\n   */\n  async append(block) {\n    const ops = [];\n    this.blockchain.push(block.hash);\n    let height = this.getCurHeightSync();\n\n    if ((height + 1) % chunkSize === 0) {\n      const serialNum = Math.floor((height + 1) / chunkSize) - 1;\n      const buf = Buffer.from(this.blockchain.slice(height + 1 - chunkSize).join(''), 'hex');\n      ops.push({ type: 'put', key: this.genKey(`chunk_${serialNum}`), value: buf });\n    }\n\n    return this.store.appendBlock(block, ops);\n  }\n\n  /**\n   * Append a branch on a specific location on the blockchain, and the \n   * new branch will be the main blockchain branch.\n   * \n   * TODO update chunk index\n   */\n  async appendAt(blocks) {\n    // some cautious checks\n    if (!blocks.length) { return; }\n    if (blocks[blocks.length - 1].height <= this.getCurHeightSync()) {\n      throw new Error('Trying to append a invalid subchain, abort.');\n    }\n\n    let at = blocks[0].height;\n    let blockIds = blocks.map(block => block.hash);\n    this.blockchain.splice(at, Number.MAX_SAFE_INTEGER, ...blockIds);\n\n    let chunkAt = Math.floor(at / chunkSize);\n    let ops = [];\n\n    for (let i = chunkAt * chunkSize; i + chunkSize < this.blockchain.length; i += chunkSize) {\n      let buf = Buffer.from(this.blockchain.slice(i, i + chunkSize).join(''), 'hex');\n      ops.push({ type: 'put', key: this.genKey(`chunk_${i / chunkSize}`), value: buf });\n    }\n\n    return this.store.appendBlocksAt(blocks, ops);\n  }\n\n  /**\n   * Return the head block, or `undefined` when there's no\n   * block on the blockchain.\n   */\n  async getHeadBlock() {\n    let blockId = await this.store.readHeadBlock();\n    return this.getBlock(blockId);\n  }\n\n  /**\n   * Synchronously get current head block's id. If there is no block\n   * yet, `undefined` will be returned.\n   */\n  getHeadBlockIdSync() {\n    let length = this.blockchain.length;\n    return length ? this.blockchain[length - 1] : undefined;\n  }\n\n  getBlockIdAtSync(height) {\n    let curHeight = this.getCurHeightSync();\n    if (height < 0 || height > curHeight) {\n      throw new Error('Invalid height given.');\n    }\n\n    return this.blockchain[height];\n  }\n\n  /**\n   * Note that height is 0-based (first block's height is 0).\n   * If there's no block yet, `-1` will returned.\n   */\n  async getCurHeight() {\n    let block = await this.getHeadBlock();\n    return block ? block.height : -1;\n  }\n\n  /**\n   * Note that height is 0-based (first block's height is 0).\n   * If there's no block yet, `-1` will returned.\n   */\n  getCurHeightSync() {\n    return this.blockchain.length - 1;\n  }\n\n  /**\n   * Get a list of block locator hashes, which is used in the\n   * `getBlocks` message that typically exists in blockchain\n   * protocol.\n   */\n  getLocatorsSync() {\n    let locators = [];\n    let height = this.getCurHeightSync();\n    let pow = 0;\n\n    if (height === -1) { return []; }\n\n    while (true) {\n      let i = Math.max(height + 1 - Math.pow(2, pow), 0);\n      locators.push(this.getBlockIdAtSync(i));\n      if (i === 0) { break; }\n      pow += 1;\n    }\n    return locators;\n  }\n\n  /**\n   * Get forked branch based on locators (an array of block hashes) peer provides.\n   * Return an array of block ids (from elder blocks to latest ones).\n   */\n  getForkedBranchSync(locators) {\n    if (this.blockchain.length < locators.length) {\n      return [];\n    }\n\n    let height = this.getCurHeightSync();\n    if (height === -1) { return []; }\n    let i = height;\n\n    for (; i >= 0; i--) {\n      let blockId = this.blockchain[i];\n      if (locators.includes(blockId)) {\n        break;\n      }\n    }\n\n    if (i === height) { return []; }\n    return this.blockchain.slice(i + 1);\n  }\n\n  /**\n   * @param {*} height note that height is 0-based index\n   */\n  async getBlockAt(height) {\n    // just to be cautious\n    if (height >= this.blockchain.length) {\n      throw new Error('Invalid block height.');\n    }\n\n    let blockId = this.blockchain[height];\n    return this.getBlock(blockId);\n  }\n\n  /**\n   * Get all blocks on the blockchain main branch.\n   * At this point there is no pagination yet, so this\n   * operation is very expensive.\n   */\n  async getBlocks(reverse = true) {\n    let blocks = await Promise.all(\n      this.blockchain.map(this.getBlock, this)\n    );\n    if (reverse) { blocks.reverse(); }\n    return blocks;\n  }\n\n  /**\n   * Return the whole block specified by the given block id.\n   * If block doesn't exist, `undefined` will be returned.\n   */\n  async getBlock(blockId) {\n    return this.store.readBlock(blockId);\n  }\n\n  /**\n   * If the given block is not on the main blockchain, the confirmation\n   * count will always be 0.\n   */\n  getConfirmationCntSync(blockId) {\n    if (!this.onMainBranchSync(blockId)) { return null; }\n\n    return this.getCurHeightSync() - this.blockchain.indexOf(blockId);\n  }\n\n  /**\n   * Determine whether the given block is on the main blockchain branch.\n   * The difference from the func `hasBlock` is that this is a synchronous\n   * operation.\n   */\n  onMainBranchSync(blockId) {\n    return this.blockchain.includes(blockId);\n  }\n\n  /**\n   * By default, return true only if the given block is on the main blockchain\n   * branch. If you want it to return true even if the block is off main branch,\n   * set the `onMainBranch` to false.\n   */\n  async hasBlock(blockId, onMainBranch = true) {\n    if (onMainBranch) {\n      return this.blockchain.includes(blockId);\n    }\n\n    return await this.getBlock(blockId) !== undefined;\n  }\n}\n\nmodule.exports = Blockchain;\n","const http = require('http');\nconst express = require('express');\nconst logger = require('morgan');\nconst cookieParser = require('cookie-parser');\nconst bodyParser = require('body-parser');\nconst { isValidJson, parseChunk } = require('../utils/common');\n\nconst notfoundPayload = { 'not-found': true };\n\n/**\n * filter log entries\n */\nfunction logFilter(logs, { peer, dir, type, since }) {\n  return logs.filter(log => (\n    (!peer || log.peer.startsWith(peer))\n    && (!dir || log.dir.startsWith(dir))\n    && (!type || log.msg.messageType.startsWith(type))\n    && (!since || log.time > since)\n  ));\n}\n\n/**\n * create a very minimalist rest server for debugging\n */\nfunction createRestServer(liteProtocol) {\n  const app = express();\n  const blockchain = liteProtocol.blockchain;\n  const liteStore = liteProtocol.liteStore;\n  const leveldb = liteProtocol.liteStore.db;\n\n  app.use(logger('dev'));\n  app.use(cookieParser());\n  app.use(bodyParser.json());\n  app.use(bodyParser.urlencoded({ extended: false }));\n\n  app.get('/', (req, res) => {\n    res.status(200).json({\n      endpoints: [\n        { '/msgpool': 'pending litemessage pool' },\n        { '/blocks': 'get all blocks on the main branch' },\n        { '/blocks/:blockId': 'get specified block' },\n        { '/litemsgs/:litemsgId': 'get a litemessage\\'s info on blockchain' },\n        { '/logs': 'protocol message logs' },\n        { '/litedb/:key': 'fetch any leveldb value of a given key' },\n        { '/locators': 'get the block locator hashes' }\n      ]\n    });\n  });\n\n  app.get('/msgpool', (req, res) => {\n    res.status(200).json(liteProtocol.litemsgPool);\n  });\n\n  app.get('/blocks', async (req, res) => {\n    let blocks = await blockchain.getBlocks();\n\n    let { simple } = req.query;\n    if (simple && simple.toLowerCase() === 'true') {\n      blocks = blocks.map(block => ({ [block.height]: block.hash }));\n    }\n\n    res.status(200).json(blocks);\n  });\n\n  app.get('/blocks/:blockId', async (req, res, next) => {\n    try {\n      let { blockId } = req.params;\n      let block = await liteProtocol.blockchain.getBlock(blockId);\n\n      if (block) {\n        res.status(200).json(block);\n      } else {\n        res.status(404).json(notfoundPayload);\n      }\n\n    } catch (err) {\n      next(err);\n    }\n  });\n\n  app.get('/litemsgs/:litemsgId', async (req, res, next) => {\n    try {\n      let { litemsgId } = req.params;\n      let at = await liteStore.readLitemsg(litemsgId);\n\n      if (typeof at === 'undefined') {\n        res.status(404).json(notfoundPayload);\n        return;\n      }\n\n      let mainBranch = blockchain.onMainBranchSync(at);\n      let confirmation = mainBranch ?\n        blockchain.getConfirmationCntSync(at) :\n        'N/A';\n      \n      res.status(200).json({ at, mainBranch, confirmation });\n\n    } catch (err) {\n      next(err);\n    }\n  });\n\n  app.get('/logs', (req, res) => {\n    let logs = liteProtocol.litenode.messageLogs;\n    let { peer, dir, type, since } = req.query;\n    if (typeof since === 'string') {\n      since = parseInt(since);\n    }\n\n    res.status(200).json(logFilter(logs, { peer, dir, type, since }));\n  });\n\n  app.get('/litedb/:key', async (req, res, next) => {\n    try {\n      let { key } = req.params;\n      let buf = await leveldb.get('lite/' + key);\n      let str = key.startsWith('chunk_') ?\n        JSON.stringify(parseChunk(buf)) :\n        buf.toString();\n\n      let payload = isValidJson(str) ? JSON.parse(str) : { _$: str };\n      res.status(200).json(payload);\n\n    } catch (err) {\n      if (err.notFound) {\n        res.status(404).json(notfoundPayload);\n      } else {\n        next(err);\n      }\n    }\n  });\n\n  app.get('/locators', (req, res) => {\n    let locators = blockchain.getLocatorsSync();\n    res.status(200).json(locators);\n  });\n\n  return http.createServer(app);\n}\n\nmodule.exports = createRestServer;\n","module.exports = require(\"http\");","module.exports = require(\"express\");","module.exports = require(\"morgan\");","module.exports = require(\"cookie-parser\");","module.exports = require(\"body-parser\");","const fs = require('fs');\nconst leveldown = require('leveldown');\nconst levelup = require('levelup');\nconst LiteNode = require('./litenode');\n\nconst nodeTypes = ['full', 'thin'];\nconst nodeType = 'full';\n\n/**\n * The Litemessage fully functional node client.\n * \n * TODO fails to bind should crash the client imediately\n * TODO a base node class\n * TODO abort unknown node type at low level (`validNodeTypes`)\n * TODO several leveldb store, or just one\n * TODO bind to different interfaces\n */\nclass FullNode {\n  /**\n   * Note `port` here must be number (instead of string).\n   */\n  constructor(protocolClass, dbPath, { port = 1113, initPeerUrls = [] } = {}) {\n    this.port = port;\n    port = typeof port === 'number' ? (port + '') : undefined;\n    this.initPeerUrls = [...initPeerUrls];\n    // initialize the db (level db)\n    this.initDb(dbPath);\n    // create underlying litenode\n    this.litenode = new LiteNode(nodeType, { port });\n    // load protocol\n    this.protocol = new protocolClass(this, nodeTypes);\n\n    // connect to initial peers\n    initPeerUrls.forEach(url => this.litenode.createConnection(url));\n\n    this.timer = setInterval(() => {\n      console.log(`Right now, there are ${this.peers().length} connected peers (full & thin).`);\n      // this.debugInfo();\n    }, 20000);\n  }\n\n  static get nodeType() {\n    return nodeType;\n  }\n\n  initDb(dbPath) {\n    if (fs.existsSync(dbPath) && fs.statSync(dbPath).isDirectory()) {\n      console.log('Using existing LevelDB directory.');\n    } else {\n      console.log('A new LevelDB directory will be created.');\n    }\n    this.db = levelup(leveldown(dbPath));\n  }\n\n  /**\n   * @param {string|Array<string>} nodeType the node types (pass `*` for matching all types)\n   */\n  peers(nodeTypes = '*') {\n    if (typeof nodeTypes === 'string' && nodeTypes !== '*') {\n      nodeTypes = [nodeTypes];\n    }\n\n    let peers = this.litenode ? Object.values(this.litenode.peers) : [];\n    return peers.filter(peer => nodeTypes === '*' || nodeTypes.includes(peer.nodeType));\n  }\n\n  close(callback) {\n    clearInterval(this.timer);\n    this.litenode.close(callback);\n    this.db.close();\n  }\n\n  debugInfo() {\n    console.log('<<<<< debug start >>>>>');\n    let peerUrls = this.peers().map(peer => peer.url);\n    console.log(peerUrls);\n    console.log('<<<<<< debug end >>>>>>');\n  }\n}\n\nmodule.exports = FullNode;\n"],"sourceRoot":""}
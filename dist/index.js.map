{"version":3,"sources":["/Users/sunhe/Documents/projects/litemessage/webpack/bootstrap","/Users/sunhe/Documents/projects/litemessage/src/utils/litecrypto.js","/Users/sunhe/Documents/projects/litemessage/external \"events\"","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/messages.js","/Users/sunhe/Documents/projects/litemessage/src/utils/network.js","/Users/sunhe/Documents/projects/litemessage/src/utils/time.js","/Users/sunhe/Documents/projects/litemessage/src/utils/common.js","/Users/sunhe/Documents/projects/litemessage/src/clients/node.js","/Users/sunhe/Documents/projects/litemessage/external \"url\"","/Users/sunhe/Documents/projects/litemessage/external \"ws\"","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/thinprotocol.js","/Users/sunhe/Documents/projects/litemessage/src/p2pprotocol/p2protocol.js","/Users/sunhe/Documents/projects/litemessage/external \"path\"","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/store.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/handshake.js","/Users/sunhe/Documents/projects/litemessage/src/utils/blockchain.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/rest.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/liteprotocol.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/entities/block.js","/Users/sunhe/Documents/projects/litemessage/index.js","/Users/sunhe/Documents/projects/litemessage/external \"uuid/v1\"","/Users/sunhe/Documents/projects/litemessage/external \"levelup\"","/Users/sunhe/Documents/projects/litemessage/src/litenode.js","/Users/sunhe/Documents/projects/litemessage/src/wsc.js","/Users/sunhe/Documents/projects/litemessage/src/wss.js","/Users/sunhe/Documents/projects/litemessage/external \"fs\"","/Users/sunhe/Documents/projects/litemessage/external \"leveldown\"","/Users/sunhe/Documents/projects/litemessage/src/clients/thinnode.js","/Users/sunhe/Documents/projects/litemessage/src/p2pprotocol/store.js","/Users/sunhe/Documents/projects/litemessage/src/p2pprotocol/messages.js","/Users/sunhe/Documents/projects/litemessage/external \"dns\"","/Users/sunhe/Documents/projects/litemessage/external \"util\"","/Users/sunhe/Documents/projects/litemessage/src/peer.js","/Users/sunhe/Documents/projects/litemessage/external \"crypto\"","/Users/sunhe/Documents/projects/litemessage/external \"child_process\"","/Users/sunhe/Documents/projects/litemessage/external \"bluebird\"","/Users/sunhe/Documents/projects/litemessage/external \"buffer\"","/Users/sunhe/Documents/projects/litemessage/external \"http\"","/Users/sunhe/Documents/projects/litemessage/external \"express\"","/Users/sunhe/Documents/projects/litemessage/external \"morgan\"","/Users/sunhe/Documents/projects/litemessage/external \"cookie-parser\"","/Users/sunhe/Documents/projects/litemessage/external \"body-parser\"","/Users/sunhe/Documents/projects/litemessage/src/clients/fullnode.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/miner.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/resolv-handler.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/inv-resolv.js","/Users/sunhe/Documents/projects/litemessage/src/liteprotocol/entities/litemsg.js"],"names":[],"mappings":";;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;AClFA;AACA;;AAEA;AACA;AACA,OAAO,OAAO;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,CAAC,6BAKD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,0CAA0C;AACrF;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL,CAAC,QAID;;AAEA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,8BAA8B,UAAU,EAAE,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,sBAAsB;AAC9B;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;;AAEnC,OAAO,wCAAwC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,OAAO;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA,eAAe,cAAc;;AAE7B,OAAO,uDAAuD;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,gBAAgB,EAAE,WAAW,EAAE,KAAK,EAAE,MAAM;AACzF;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,cAAc;AAChD;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,cAAc;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;;AAE7B,OAAO,uDAAuD;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,gBAAgB,EAAE,WAAW,EAAE,KAAK,EAAE,MAAM;AACzF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,cAAc;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,CAAC,QAID;;;;;;;AC9TA,mC;;;;;;ACAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA;AACA,CAAC;;AAED,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA,CAAC;;AAED,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA,CAAC;;AAED,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA,CAAC;;AAED,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA,CAAC;;AAED,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA,CAAC;;AAED,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA,CAAC;;AAED,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA,CAAC;;AAED,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA,CAAC;;AAED,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;;AAEA,kBAAkB,SAAS;AAC3B;AACA;AACA,CAAC;;AAED,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA,WAAW,EAAE;AACb;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA,CAAC;;AAED,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA,CAAC;;AAED,6BAA6B,2BAA2B;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA,YAAY,yBAAyB,GAAG,sBAAsB;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK,wBAAwB,GAAG,qBAAqB;;AAErD;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;;;;;;;ACbA;AACA;AACA;AACA,CAAC,QAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,0CAA0C;;AAErE;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC,QAED;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACvFA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC,sBAID;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C,wBAAwB;AACrE;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC5EA,gC;;;;;;ACAA,+B;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC,QAED;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kCAAkC;AACnD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,gCAAgC,iBAAiB;AACjD,gCAAgC,qBAAqB;AACrD;;AAEA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,WAAW,SAAS;;AAEpB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,qCAAqC,gBAAgB;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC5MA;AACA;AACA;AACA,CAAC;AACD,OAAO,YAAY;;AAEnB;AACA;;AAEA;AACA,OAAO,MAAM;AACb;AACA,OAAO,YAAY;;AAEnB;AACA;;AAEA,CAAC,2BAID;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iCAAiC,KAAK;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,2BAA2B;AAC3D,gCAAgC,4BAA4B;;AAE5D;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,YAAY;AAChE;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;;AAEA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA,KAAK;AACL;AACA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;AACA;AACA;;AAEA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtKA,iC;;;;;;ACAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;;AAEA,KAAK;AACL,yBAAyB,kBAAkB;AAC3C;AACA;AACA;;AAEA;AACA,yCAAyC,UAAU;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,kBAAkB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,QAAQ;AAC1D;;AAEA,KAAK;AACL,yBAAyB,kBAAkB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO,mCAAmC,WAAW,kCAAkC;AACvF,OAAO;AACP;AACA;AACA;AACA,kBAAkB,qCAAqC,aAAa,uBAAuB;AAC3F;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA,yBAAyB,QAAQ;;AAEjC;AACA;;AAEA;AACA,2CAA2C,wCAAwC;;AAEnF,gBAAgB,mCAAmC,WAAW,kCAAkC;AAChG;AACA;AACA,oBAAoB,qCAAqC,aAAa,uBAAuB;AAC7F;AACA;AACA;AACA,cAAc,gEAAgE;;AAE9E,mBAAmB,6BAA6B;;AAEhD;AACA;AACA;;AAEA;;;;;;;ACpJA;AACA;AACA;AACA,iBAAiB;AACjB,CAAC;AACD,OAAO,kBAAkB;AACzB,OAAO,mBAAmB;;AAE1B;AACA;;AAEA;;AAEA,CAAC,2BAID;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;;AAEA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,0BAA0B;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa;AACb;AACA;AACA;;AAEA,SAAS;AACT,gDAAgD,yBAAyB,aAAa,UAAU;AAChG;AACA;AACA;;AAEA,OAAO,aAAa;;AAEpB;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL,4CAA4C,yBAAyB,aAAa,IAAI;AACtF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS,+CAA+C;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;;;;;;AC/MA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;;AAEA;AACA,wCAAwC,iBAAiB;;AAEzD,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,wCAAwC,UAAU,gBAAgB;AAClF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,wCAAwC;AAC7E;AACA,gBAAgB,wCAAwC,cAAc,gBAAgB;AACtF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;;AAEnC;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,WAAW;AACnC;;AAEA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;;AAEA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C,aAAa;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;ACnUA;AACA;AACA;AACA;AACA;AACA,OAAO,0BAA0B;;AAEjC,yBAAyB;;AAEzB;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,kBAAkB;;AAEnD;AACA;AACA;AACA,SAAS,+CAA+C;AACxD,SAAS,+BAA+B;AACxC,SAAS,yCAAyC;AAClD,SAAS,iDAAiD;AAC1D,SAAS,4CAA4C;AACrD,SAAS,oEAAoE;AAC7E,SAAS,mCAAmC;AAC5C,SAAS,2DAA2D;AACpE,SAAS;AACT;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA,SAAS,OAAO;AAChB;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA,SAAS,SAAS;AAClB;AACA,qCAAqC,6BAA6B;AAClE;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,WAAW,UAAU;AACrB;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,WAAW,YAAY;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,+BAA+B;;AAE3D,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;;AAEA,0CAA0C,yBAAyB;AACnE,GAAG;;AAEH;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;;AAEA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD,OAAO,YAAY;AACnB,OAAO,kBAAkB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,kCAAkC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,gCAAgC,uBAAuB;AACvD,gCAAgC,iBAAiB;AACjD,gCAAgC,qBAAqB;AACrD,gCAAgC,wBAAwB;AACxD,gCAAgC,kBAAkB;AAClD,gCAAgC,4BAA4B;AAC5D,gCAAgC,4BAA4B;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;;AAEA;AACA;AACA;AACA,0DAA0D,QAAQ;;AAElE;AACA;AACA;AACA,SAAS,cAAc,mBAAmB;;AAE1C,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,S;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD,UAAU,OAAO,WAAW;;AAEjF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA,WAAW,gBAAgB;AAC3B;;AAEA;AACA;AACA,2BAA2B,uBAAuB;AAClD;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,wBAAwB,0BAA0B;AAClD;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;;AAEA;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,2BAA2B,0BAA0B;AACrD;AACA;AACA,WAAW,SAAS;;AAEpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA,WAAW,mBAAmB;AAC9B,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,qCAAqC,gBAAgB;AACrD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kDAAkD,UAAU;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,+CAA+C;AAC9D;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA,WAAW,WAAW;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,yBAAyB,0BAA0B;AACnD;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,WAAW;AACtC;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;;AAEA;;;;;;;AC3cA,OAAO,SAAS;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,KAAK,EAAE,MAAM;AACjF;AACA,UAAU;AACV;;AAEA;;;;;;;AC1BA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;;AAE/B,8BAA8B;AAC9B,8BAA8B;;AAE9B,CAAC,QAID;;;;;;;ACnBA,oC;;;;;;ACAA,oC;;;;;;ACAA;AACA,OAAO,mBAAmB;AAC1B,OAAO,kBAAkB;;AAEzB;AACA;AACA;AACA;AACA,CAAC,2BAGD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,qBAAqB,+CAA+C,KAAK;AACzE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,4BAA4B,KAAK;AAC7D,oBAAoB,uCAAuC;AAC3D,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;;AAErC;;AAEA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD,cAAc;AACnE,KAAK;AACL,sDAAsD,cAAc;AACpE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS,0BAA0B,EAAE;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,UAAU,GAAG,cAAc;AAClE;AACA;AACA;AACA,iDAAiD,cAAc,IAAI,cAAc,KAAK,gBAAgB;AACtG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mCAAmC;AAC5C;;AAEA;AACA,oEAAoE,KAAK,GAAG,cAAc,EAAE;AAC5F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C,UAAU,GAAG,cAAc,IAAI,SAAS;AACtF,KAAK;AACL,+CAA+C,UAAU,GAAG,cAAc,IAAI,SAAS;AACvF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChQA,OAAO,iDAAiD;;AAExD;AACA;;AAEA;AACA,OAAO,MAAM;AACb;;AAEA,CAAC,sCAeD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAA8C;AACtD,+DAA+D,mBAAmB;AAClF,KAAK;AACL,oCAAoC,IAAI;AACxC;;AAEA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA;;AAEA,qCAAqC,0BAA0B;;AAE/D;AACA,uDAAuD,IAAI,cAAc,IAAI;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7KA;AACA;AACA,OAAO,MAAM;AACb,OAAO,kCAAkC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8CAA8C;AACtD,+DAA+D,mBAAmB;AAClF,KAAK;AACL,oCAAoC,IAAI;AACxC;;AAEA;AACA;AACA,oDAAoD,IAAI;AACxD;AACA;;AAEA,qCAAqC,0BAA0B;;AAE/D;AACA,uDAAuD,IAAI,cAAc,IAAI;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC7KA,+B;;;;;;ACAA,sC;;;;;;ACAA;AACA;;AAEA;;AAEA;AACA,uBAAuB,mEAAmE,KAAK;AAC/F;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACnBA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;;AAEA;;;;;;;AC9BA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,qBAAqB,wBAAwB,KAAK;AAClD;AACA;AACA;AACA,CAAC;;AAED,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,sBAAsB,2BAA2B,KAAK;AACtD;AACA;AACA;AACA,CAAC;;AAED,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;;;;;;ACvDA,gC;;;;;;ACAA,iC;;;;;;ACAA,OAAO,qCAAqC;;AAE5C;AACA;AACA,aAAa,OAAO;AACpB,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB,GAAG,WAAW;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,cAAc,cAAc,KAAK,SAAS;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACxDA,mC;;;;;;ACAA,0C;;;;;;ACAA,qC;;;;;;ACAA,mC;;;;;;ACAA,iC;;;;;;ACAA,oC;;;;;;ACAA,mC;;;;;;ACAA,0C;;;;;;ACAA,wC;;;;;;ACAA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAA+D,KAAK;AAC3F;;AAEA;AACA,0CAA0C,oBAAoB;AAC9D;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtCA,OAAO,OAAO;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA;AACA,WAAW,2DAA2D;AACtE,uBAAuB,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,UAAU,EAAE,WAAW,EAAE,KAAK;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;ACtDA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,4BAA4B;AAC5D;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA,WAAW,iCAAiC;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;;AAEV,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV,OAAO;;AAEP,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;ACtDA,OAAO,aAAa;AACpB,OAAO,kBAAkB;AACzB,OAAO,8BAA8B;AACrC;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,EAAE;AACf,aAAa,EAAE;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qCAAqC,KAAK;AAC7E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,yBAAyB;AACzD,gCAAgC,6BAA6B;AAC7D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,SAAS;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,gCAAgC,WAAW;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE;AACf;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,0BAA0B;AACtD;AACA;AACA,WAAW,uBAAuB;AAClC;AACA,sBAAsB,oDAAoD;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;;AAE3C;AACA;;AAEA;AACA;AACA,qBAAqB,kBAAkB;AACvC,gBAAgB,+BAA+B;AAC/C;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,gCAAgC,0BAA0B;AAC1D;AACA;;AAEA;AACA,uCAAuC,QAAQ;;AAE/C;AACA,4CAA4C,yBAAyB;AACrE,4CAA4C,6BAA6B;AACzE;AACA;AACA;;AAEA;;;;;;;AC1QA,OAAO,SAAS;;AAEhB;AACA,WAAW,OAAO;AAClB,WAAW,IAAI;AACf,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA,uBAAuB,IAAI,EAAE,KAAK,EAAE,QAAQ,EAAE,IAAI,EAAE,OAAO;AAC3D,UAAU;AACV;;AAEA","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 18);\n","if (BUILD_TARGET === 'node') {\n  // node\n\n  var path = require('path');\n  var crypto = require('crypto');\n  var { fork } = require('child_process');\n  var Promise = require('bluebird');\n  var Buffer = require('buffer').Buffer;\n\n  Promise.config({\n    // enable warnings\n    warnings: true,\n    // enable long stack traces\n    longStackTraces: true,\n    //enable cancellation\n    cancellation: true\n  });\n\n} else {\n  // browser\n\n  var sha256 = require('js-sha256');\n  var Buffer = require('buffer/').Buffer;\n}\n\n// ********************* requiring ends *********************\n\nconst maskTable = Object.freeze([\n  0x80, \n  0x40, \n  0x20,\n  0x10,\n  0x08,\n  0x04,\n  0x02,\n  0x01\n]);\n\nif (BUILD_TARGET === 'node') {\n  // node\n\n  var sha256 = (content, digest = 'hex') => \n    crypto.createHash('sha256')\n      .update(content)\n      .digest(digest);\n\n  var mine = (content, difficulty) => \n    new Promise((resolve, reject, onCancel) => {\n      if (typeof difficulty !== 'number') { reject(new Error('Invalid difficulty.')); }\n      let cp = fork(path.join(__dirname, 'mine.js'), [content, difficulty]);\n  \n      let timer = setTimeout(() => {\n        cp.removeAllListeners();\n        cp.kill('SIGTERM');\n        reject(new Error('Mining timeouts.'));\n  \n        // disable timeout in production\n      }, 600000);\n  \n      cp.on('message', (nonce) => {\n        clearTimeout(timer);\n        resolve(nonce);\n      });\n      \n      onCancel(() => {\n        clearTimeout(timer);\n        cp.removeAllListeners();\n        cp.kill('SIGTERM');\n      });\n    });\n\n} else {\n  // browser\n\n  // nothing here\n}\n\n/**\n * @param {Array<string>} leaves  list of litemessage ids\n */\nconst calcMerkleRoot = (leaves) => {\n  if (leaves.length === 0) {\n    throw new Error('Cannot calcuate merkle root from 0 leaf.');\n  }\n  if (leaves.length % 2 === 1) {\n    leaves = [...leaves, leaves[leaves.length - 1]]\n  }\n  let innerNodes = [];\n  for (let i = 0; i < leaves.length; i += 2) {\n    innerNodes.push(sha256(`${leaves[i]}${leaves[i + 1]}`));\n  }\n  if (innerNodes.length === 1) {\n    return innerNodes[0];\n  }\n  return calcMerkleRoot(innerNodes);\n}\n\n/**\n * If verification passes, `true` will be returned.\n */\nconst verifyMerkleRoot = (merkleRoot, leaves) => {\n  return merkleRoot === calcMerkleRoot(leaves);\n}\n\n/**\n * @param {Buffer|string} buffer binary buffer or string in hex encoding\n */\nconst leadingZeroBits = (buffer) => {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer, 'hex');\n  }\n  let bits = 0;\n  let byteAt = 0;\n\n  for (; buffer[byteAt] === 0; byteAt++) {\n    bits += 8;\n  }\n  for (let bitAt = 0; bitAt < 8; bitAt++) {\n    if (buffer[byteAt] & maskTable[bitAt]) {\n      break;\n    }\n    bits += 1;\n  }\n\n  return bits;\n}\n\n/**\n * TODO validate timestamp, sig, pubKey\n * For timestamp, need to consider how long it takes to\n * populate the network.\n */\nconst verifyLitemsg = (litemessage) => {\n  if (!litemessage) { return false; }\n\n  let { ver, time, litemsg, sig, pubKey, hash } = litemessage;\n\n  if (typeof ver !== 'number') {\n    return false;\n  }\n  if (typeof time !== 'number') {\n    return false;\n  }\n  if (typeof litemsg !== 'string') {\n    return false;\n  }\n  if (hash !== sha256(`${ver}${time}${litemsg}${sig}${pubKey}`)) {\n    return false;\n  }\n  return true;\n};\n\n/**\n * TODO validate timestamp, bits (its value)\n * \n * Note that if you don't pass `prevBlock`, this func won't verify `height` (though\n * it still must be a positive number) and `prevBlock` (though it still must be \n * `undefined` when `height` is 0).\n * \n * When verifying genesis block (the first block), you shouldn't pass `prevBlock`\n * parameter.\n * \n * @param {*} block     the block to verify\n * @param {*} prevBlock (optional) previous block (not id), which the verified\n *                      block should be after immediately\n */\nconst verifyBlock = (block, prevBlock) => {\n  if (!block) { return false; }\n\n  let { ver, time, height, merkleRoot, bits, nonce, litemsgs } = block;\n\n  if (typeof ver !== 'number') {\n    return false;\n  }\n  if (typeof time !== 'number') {\n    return false;\n  }\n  if (typeof height !== 'number' || height < 0 || \n    (height === 0 && typeof block.prevBlock !== 'undefined') ||\n    (height !== 0 && typeof block.prevBlock === 'undefined')) {\n\n    return false;\n  }\n  if (!(litemsgs instanceof Array) || !litemsgs.length) {\n    return false;\n  }\n  if (typeof merkleRoot !== 'string' || !verifyMerkleRoot(merkleRoot, litemsgs.map(m => m.hash))) {\n    return false;\n  }\n  \n  /* bits, nonce, hash */\n  if (typeof bits !== 'number'|| typeof nonce !== 'number'\n    || nonce < 0 || typeof block.hash !== 'string') {\n    \n    return false;\n  }\n  let hash = sha256(`${ver}${time}${height}${block.prevBlock}${merkleRoot}${bits}${nonce}`);\n  if (hash !== block.hash || leadingZeroBits(hash) < bits) {\n    return false;\n  }\n\n  /* litemsgs */\n  for (let litemsg of litemsgs) {\n    if (!verifyLitemsg(litemsg)) { return false; }\n  }\n\n  /* height, prevBlock */\n  if (typeof prevBlock !== 'undefined') {\n    if (typeof block.prevBlock !== 'string' || prevBlock.hash !== block.prevBlock) {\n      return false;\n    }\n\n    if (prevBlock.height + 1 !== height) { return false; }\n  }\n  return true;\n};\n\n/**\n * Similar to `verifyBlock`. However, `litemsgs` MUST be `undefined`.\n * \n * TODO validate timestamp, bits (its value)\n */\nconst verifyHeader = (block, prevBlock) => {\n  if (!block) { return false; }\n\n  let { ver, time, height, merkleRoot, bits, nonce, litemsgs } = block;\n\n  if (typeof ver !== 'number') {\n    return false;\n  }\n  if (typeof time !== 'number') {\n    return false;\n  }\n  if (typeof height !== 'number' || height < 0 || \n    (height === 0 && typeof block.prevBlock !== 'undefined') ||\n    (height !== 0 && typeof block.prevBlock === 'undefined')) {\n\n    return false;\n  }\n  if (litemsgs !== undefined) {\n    return false;\n  }\n  if (typeof merkleRoot !== 'string') {\n    return false;\n  }\n  \n  /* bits, nonce, hash */\n  if (typeof bits !== 'number'|| typeof nonce !== 'number'\n    || nonce < 0 || typeof block.hash !== 'string') {\n    \n    return false;\n  }\n  let hash = sha256(`${ver}${time}${height}${block.prevBlock}${merkleRoot}${bits}${nonce}`);\n  if (hash !== block.hash || leadingZeroBits(hash) < bits) {\n    return false;\n  }\n\n  /* height, prevBlock */\n  if (typeof prevBlock !== 'undefined') {\n    if (typeof block.prevBlock !== 'string' || prevBlock.hash !== block.prevBlock) {\n      return false;\n    }\n\n    if (prevBlock.height + 1 !== height) { return false; }\n  }\n  return true;\n};\n\n/**\n * Note that `subchain` start from elder blocks to newer blocks, which is a\n * block array.\n * \n * Parameter `prevBlock` should always be a valid block (NEVER pass un-verified\n * blocks received from peers). Or when the subchain starts at genesis block, \n * do not pass parameter `prevBlock` (leave it as `undefined`).\n */\nconst verifySubchain = (subchain, prevBlock) => {\n  for (let block of subchain) {\n    if (!verifyBlock(block, prevBlock)) {\n      return false;\n    }\n    prevBlock = block;\n  }\n  return true;\n};\n\n/**\n * Similar to `verifySubchain`.\n */\nconst verifyHeaderChain = (headerChain, prevHeader) => {\n  for (let block of headerChain) {\n    if (!verifyHeader(block, prevHeader)) {\n      return false;\n    }\n    prevHeader = block;\n  }\n  return true;\n};\n\nexports.sha256 = sha256;\nexports.calcMerkleRoot = calcMerkleRoot;\nexports.verifyMerkleRoot = verifyMerkleRoot;\nexports.leadingZeroBits = leadingZeroBits;\nexports.verifyLitemsg = verifyLitemsg;\nexports.verifyBlock = verifyBlock;\nexports.verifySubchain = verifySubchain;\nexports.verifyHeader = verifyHeader;\nexports.verifyHeaderChain = verifyHeaderChain;\n\nif (BUILD_TARGET === 'node') {\n  // node\n\n  exports.mine = mine;\n\n} else {\n  // browser\n\n  // nothing here\n}\n","module.exports = require(\"events\");","const messageTypes = Object.freeze({\n  info: 'lite/info',\n  infoAck: 'lite/info_ack',\n\n  getBlocks: 'lite/get_blocks',\n  inv: 'lite/inv',\n  getData: 'lite/get_data',\n  data: 'lite/data',\n  getDataPartial: 'lite/get_data_partial',\n  dataPartial: 'lite/data_partial',\n  partialNotFound: 'lite/partial_not_found',\n\n  getPendingMsgs: 'lite/get_pending_msgs',\n\n  getHeaders: 'lite/get_headers',\n  headers: 'lite/headers',\n  locateLitemsgs: 'lite/locate_litemsgs',\n  litemsgLocators: 'lite/litemsg_locators',\n});\n\nconst info = ({ uuid, nodeType, daemonPort }) => ({\n  messageType: messageTypes.info,\n  uuid,\n  nodeType,\n  daemonPort\n});\n\ninfo.validate = ({ uuid, nodeType, daemonPort }) => {\n  if (typeof uuid !== 'string') {\n    throw new Error('lite/: Invalid uuid.');\n  }\n  if (nodeType !== 'full' && nodeType !== 'thin') {\n    throw new Error('lite/: Invalid node type.');\n  }\n  if (daemonPort !== undefined && (typeof daemonPort !== 'number' \n      || daemonPort <= 1024 || daemonPort > 65535)) {\n    throw new Error('lite/: Invalid daemon port.');\n  }\n  if (nodeType === 'full' && !daemonPort) {\n    throw new Error('lite/: Invalid daemon port.');\n  }\n};\n\nconst infoAck = () => ({\n  messageType: messageTypes.infoAck\n});\n\ninfoAck.validate = () => {\n  // nothing here\n}\n\nconst getBlocks = ({ blockLocators }) => ({\n  messageType: messageTypes.getBlocks,\n  blockLocators\n});\n\ngetBlocks.validate = ({ blockLocators }) => {\n  if (!(blockLocators instanceof Array)) {\n    throw new Error('lite/: Invalid block locators.');\n  }\n};\n\n/**\n * both params are list of ids\n */\nconst inv = ({ blocks = [], litemsgs = [] }) => ({\n  messageType: messageTypes.inv,\n  blocks,\n  litemsgs\n});\n\ninv.validate = ({ blocks, litemsgs }) => {\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n  if (!(litemsgs instanceof Array)) {\n    throw new Error('lite/: Invalid lite messages.');\n  }\n};\n\n/**\n * both params are list of ids\n */\nconst getData = ({ blocks = [], litemsgs = [] }) => ({\n  messageType: messageTypes.getData,\n  blocks,\n  litemsgs\n});\n\ngetData.validate = ({ blocks, litemsgs }) => {\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n  if (!(litemsgs instanceof Array)) {\n    throw new Error('lite/: Invalid lite messages.');\n  }\n};\n\nconst data = ({ blocks = [], litemsgs = [] }) => ({\n  messageType: messageTypes.data,\n  blocks,\n  litemsgs\n});\n\ndata.validate = ({ blocks, litemsgs }) => {\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n  if (!(litemsgs instanceof Array)) {\n    throw new Error('lite/: Invalid lite messages.');\n  }\n};\n\nconst getDataPartial = ({ merkleDigest, blocks }) => ({\n  messageType: messageTypes.getDataPartial,\n  merkleDigest,\n  blocks\n});\n\ngetDataPartial.validate = ({ merkleDigest, blocks }) => {\n  if (typeof merkleDigest !== 'string') {\n    throw new Error('lite/: Invalid merkle digest.');\n  }\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n};\n\nconst dataPartial = ({ merkleDigest, blocks }) => ({\n  messageType: messageTypes.dataPartial,\n  merkleDigest,\n  blocks\n});\n\ndataPartial.validate = ({ merkleDigest, blocks }) => {\n  if (typeof merkleDigest !== 'string') {\n    throw new Error('lite/: Invalid merkle digest.');\n  }\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n};\n\nconst partialNotFound = ({ merkleDigest, blocks }) => ({\n  messageType: messageTypes.partialNotFound,\n  merkleDigest,\n  blocks\n});\n\npartialNotFound.validate = ({ merkleDigest, blocks }) => {\n  if (typeof merkleDigest !== 'string') {\n    throw new Error('lite/: Invalid merkle digest.');\n  }\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n};\n\nconst getPendingMsgs = () => ({\n  messageType: messageTypes.getPendingMsgs\n});\n\ngetPendingMsgs.validate = () => {\n  // nothing\n};\n\nconst getHeaders = ({ blocks }) => ({\n  messageType: messageTypes.getHeaders,\n  blocks\n});\n\ngetHeaders.validate = ({ blocks }) => {\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid blocks.');\n  }\n};\n\nconst headers = ({ blocks }) => ({\n  messageType: messageTypes.headers,\n  blocks\n});\n\nheaders.validate = ({ blocks }) => {\n  if (!(blocks instanceof Array)) {\n    throw new Error('lite/: Invalid block headers.');\n  }\n}\n\n/**\n * @param {*} options\n *      `litemsgs` - ids\n */\nconst locateLitemsgs = ({ litemsgs }) => ({\n  messageType: messageTypes.locateLitemsgs,\n  litemsgs\n});\n\nlocateLitemsgs.validate = ({ litemsgs }) => {\n  if (!(litemsgs instanceof Array)) {\n    throw new Error('lite/: Invalid lite message ids.');\n  }\n};\n\n/**\n * `litemsgs` is an array of litemsg ids. \n * `blocks` is an array of blocks. \n * `lookup` stores the relation between `litemsgs` and `blocks`.\n * \n * The number of elements in `lookup` MUST be the same as `litemsgs`.\n * Each element in `lookup` is a block id. For instance, id of the \n * block which first litemessage is located is the first element of\n * `lookup.`\n * \n * In case a litemessage is not in any block, the corresponding\n * element in `lookup` MUST be undefined (or any falsy value).\n */\nconst litemsgLocators = ({ litemsgs, blocks, lookup }) => ({\n  messageType: messageTypes.litemsgLocators,\n  litemsgs,\n  blocks,\n  lookup\n});\n\nlitemsgLocators.validate = ({ litemsgs, blocks, lookup }) => {\n  // TODO verify the lookup array is correct\n};\n\n// validators\nconst messageValidators = Object.freeze({\n  [messageTypes.info]: info.validate,\n  [messageTypes.infoAck]: infoAck.validate,\n  [messageTypes.getBlocks]: getBlocks.validate,\n  [messageTypes.inv]: inv.validate,\n  [messageTypes.getData]: getData.validate,\n  [messageTypes.data]: data.validate,\n  [messageTypes.getDataPartial]: getDataPartial.validate,\n  [messageTypes.dataPartial]: dataPartial.validate,\n  [messageTypes.partialNotFound]: partialNotFound.validate,\n  [messageTypes.getPendingMsgs]: getPendingMsgs.validate,\n  [messageTypes.getHeaders]: getHeaders.validate,\n  [messageTypes.headers]: headers.validate,\n  [messageTypes.locateLitemsgs]: locateLitemsgs.validate,\n  [messageTypes.litemsgLocators]: litemsgLocators.validate,\n});\n\nexports.messageTypes = messageTypes;\nexports.messageValidators = messageValidators;\nexports.info = info;\nexports.infoAck = infoAck;\nexports.getBlocks = getBlocks;\nexports.inv = inv;\nexports.getData = getData;\nexports.data = data;\nexports.getDataPartial = getDataPartial;\nexports.dataPartial = dataPartial;\nexports.partialNotFound = partialNotFound;\nexports.getPendingMsgs = getPendingMsgs;\nexports.getHeaders = getHeaders;\nexports.headers = headers;\nexports.locateLitemsgs = locateLitemsgs;\nexports.litemsgLocators = litemsgLocators;\n","const extractSocketAddr = (url) => {\n  let result = /^ws:\\/\\/(.+):(\\d+)$/.exec(url);\n  if (result) {\n    return {\n      host: result[1],\n      port: parseInt(result[2])\n    };\n  }\n  throw new Error('Unable to extract socket address from url.');\n};\n\nconst getRemoteAddress = (socket) => {\n  if (Object.getPrototypeOf(socket).constructor.name === 'Socket') {\n    return extractSocketAddr(socket.url).host;\n  }\n  return socket._socket.remoteAddress.replace(/^.*:/, '');\n};\n\n/**\n * Note that a string will be returned.\n */\nconst getRemotePort = (socket) => {\n  if (Object.getPrototypeOf(socket).constructor.name === 'Socket') {\n    return extractSocketAddr(socket.url).port + '';\n  }\n  return socket._socket.remotePort + '';\n};\n\n/**\n * Of remote end.\n * \n * @param {*} socket \n */\nconst getSocketAddress = (socket) => {\n  return `${getRemoteAddress(socket)}:${getRemotePort(socket)}`;\n};\n\nconst getLocalAddress = (socket) => \n  Object.getPrototypeOf(socket).constructor.name === 'Socket' ?\n    undefined :\n    socket._socket.localAddress.replace(/^.*:/, '');\n\nconst getLocalPort = (socket) => \n  Object.getPrototypeOf(socket).constructor.name === 'Socket' ?\n    undefined :\n    socket._socket.localPort;\n\nconst getLocalSocketAddr = (socket) =>\n  `${getLocalAddress(socket)}:${getLocalPort(socket)}`;\n\nconst getSocketInfo = (socket) => ({\n  localSocketAddr: getLocalSocketAddr(socket),\n  remoteSocketAddr: getSocketAddress(socket)\n});\n\nconst getReadyState = (socket) => \n  Object.getPrototypeOf(socket).constructor.name === 'Socket' ?\n    socket._ws.readyState :\n    socket.readyState;\n\nexports.getRemoteAddress = getRemoteAddress;\nexports.getRemotePort = getRemotePort;\nexports.getSocketAddress = getSocketAddress;\nexports.getLocalAddress = getLocalAddress;\nexports.getLocalPort = getLocalPort;\nexports.getLocalSocketAddr = getLocalSocketAddr;\nexports.getSocketInfo = getSocketInfo;\nexports.getReadyState = getReadyState;\n","/**\n * in ms\n */\nconst getCurTimestamp = (unit = 'ms') => {\n  if (unit === 'ms') {\n    return new Date().getTime();\n  } else if (unit === 's') {\n    return Math.round(new Date().getTime() / 1000);\n  } else {\n    throw new Error('Invalid unit: ' + unit + '.');\n  }\n}\n\nexports.getCurTimestamp = getCurTimestamp;\n","if (BUILD_TARGET === 'node') {\n  // run in node\n  var path = require('path');\n} else {\n  // run in browser\n}\n\nconst isValidJson = (json) => {\n  if (typeof json !== 'string' || !json) {\n    return false;\n  }\n\n  try {\n    JSON.parse(json);\n    return true;\n  } catch (e) { }\n  return false;\n};\n\n/**\n * From 0 (inclusive) to `max` (exclusive).\n */\nconst randomInt = (max) => {\n  return Math.floor(Math.random() * Math.floor(max));\n};\n\n/**\n * Randomly pick `num` items from an array. Note that original array \n * won't be altered. And also the order of items won't be preserved \n * in the picked array.\n */\nconst pickItems = (array, num) => {\n  let copiedArray = [...array];\n  let picked = [];\n  num = Math.min(array.length, num);\n  for (let i = 0; i < num; i++) {\n    picked.push(...copiedArray.splice(randomInt(copiedArray.length), 1));\n  }\n  return picked;\n};\n\nconst sliceItems = (array, slices) => {\n  slices = Math.max( Math.min(array.length, slices), 1 );\n\n  let l = Math.floor(array.length / slices);\n  let sliced = [];\n\n  for (let i = 0; i < slices; i++) {\n    if (i + 1 === slices) {\n      sliced.push( array.slice(l * i) );\n    } else {\n      sliced.push( array.slice(l * i, l * (i + 1)) );\n    }\n  }\n  return sliced;\n};\n\nconst parseChunk = (buffer) => {\n  if (buffer.length % 32) { throw new Error('Invalid chunk buffer.'); }\n\n  let hashes = [];\n  for (let i = 0; i < buffer.length; i += 32) {\n    hashes.push(buffer.slice(i, i + 32).toString('hex'));\n  }\n  return hashes;\n};\n\nif (BUILD_TARGET === 'node') {\n  // run in node\n\n  /**\n   * project's root path, of course this file cannot be moved around\n   */\n  var getAbsRootPath = () => {\n    return path.join(__dirname, '../..');\n  };\n\n  exports.getAbsRootPath = getAbsRootPath;\n\n} else {\n  // run in browser\n}\n\nexports.isValidJson = isValidJson;\nexports.randomInt = randomInt;\nexports.pickItems = pickItems;\nexports.sliceItems = sliceItems;\nexports.parseChunk = parseChunk;\n","const uuidv1 = require('uuid/v1');\nconst levelup = require('levelup');\nconst LiteNode = require('../litenode');\n\nif (BUILD_TARGET === 'node') {\n  // run in node\n\n  var fs = require('fs');\n  var leveldb = require('leveldown');\n\n} else {\n  // run in browser\n\n  var leveldb = require('level-js');\n}\n\n/**\n * A UUID identifying this node will be automatically generated.\n * \n * TODO provide implementation in browser env examining existing db\n */\nclass Node {\n  constructor(nodeType, dbPath, port, protocolClass, initPeerUrls, debug, noserver) {\n    if (new.target === Node) {\n      throw new TypeError(\"Cannot construct Node instances directly.\");\n    }\n\n    // some necessary info\n    this.uuid = uuidv1();\n    this.nodeType = nodeType;\n    this.initPeerUrls = initPeerUrls;\n\n    if (BUILD_TARGET === 'node') {\n      if (fs.existsSync(dbPath) && fs.statSync(dbPath).isDirectory()) {\n        console.log('Using existing LevelDB directory.');\n      } else {\n        console.log('A new LevelDB directory will be created.');\n      }\n    }\n\n    // initialize the database (Level DB)\n    this.db = levelup(leveldb(dbPath));\n\n    // create underlying litenode\n    this.litenode = new LiteNode(this.uuid, { port, debug, noserver });\n    // instantiate the protocol manager\n    this.protocol = new protocolClass(this);\n\n    this.protocol.on('ready', () => {\n      // connect to initial peers\n      this.initPeerUrls.forEach(url => this.litenode.createConnection(url));\n    });\n  }\n\n  /**\n   * @param {string|Array<string>} nodeTypes pass `*` for matching all types\n   */\n  peers(nodeTypes = '*') {\n    if (typeof nodeTypes === 'string' && nodeTypes !== '*') {\n      nodeTypes = [nodeTypes];\n    }\n\n    let peers = this.litenode ? Object.values(this.litenode.peers) : [];\n    return peers.filter(peer => nodeTypes === '*' || nodeTypes.includes(peer.nodeType));\n  }\n\n  /**\n   * Do the cleanup.\n   */\n  close() {\n    this.protocol.close();\n    this.litenode.close();\n    this.db.close();\n  }\n}\n\nmodule.exports = Node;\n","module.exports = require(\"url\");","module.exports = require(\"ws\");","const P2PProtocol = require('../p2pprotocol/p2protocol');\nconst LiteProtocolStore = require('./store');\nconst HandshakeManager = require('./handshake');\nconst Blockchain = require('../utils/blockchain');\nconst {\n  verifyHeader, verifyHeaderChain\n} = require('../utils/litecrypto');\nconst {\n  messageTypes, messageValidators, getHeaders, getBlocks\n} = require('./messages');\n\nif (BUILD_TARGET === 'node') {\n  // run in node\n  var createRestServer = require('./rest');\n} else {\n  // run in browser\n}\n\n// protocol version\nconst VERSION = 1;\n// node types to re/connect automatically\nconst AUTO_CONN_NODE_TYPES = ['full'];\n\n/**\n * An experimental \"thin\" litemessage protocol implementation.\n * The \"thin\" here means this is a light weight implementation,\n * similar to SPV nodes in Bitcoin. Typically, client nodes\n * (such as used by common users with browser or CLI) will use\n * this tpye of implementation.\n * \n * **NOTE** that this is an experimental implementation, so it\n * probably will be refactored in the future.\n */\nclass ThinLiteProtocol extends P2PProtocol {\n  static get ver() {\n    return VERSION;\n  }\n\n  constructor(node) {\n    super(node, { nodeTypes: AUTO_CONN_NODE_TYPES });\n    this.invHandler = this.invHandler.bind(this);\n    this.headersHandler = this.headersHandler.bind(this);\n    this.peerConnectHandler = this.peerConnectHandler.bind(this);\n\n    this.litestore = new LiteProtocolStore(node.db);\n    // a blockchain manager\n    this.blockchain = new Blockchain(this.litestore);\n\n    // wait for blockchain initializing itself\n    this.blockchain.on('ready', () => this.init());\n    // or upon error\n    this.blockchain.on('error', err => {\n      console.error(err);\n      process.exit(1);\n    });\n  }\n\n  init() {\n    // register message/connection handlers\n    this.litenode.on(`message/${messageTypes.inv}`, this.invHandler);\n    this.litenode.on(`message/${messageTypes.headers}`, this.headersHandler);\n    this.litenode.on('peerconnect', this.peerConnectHandler);\n\n    this.handshake = new HandshakeManager(this);\n\n    if (this.litenode.debug && BUILD_TARGET === 'node') {\n      // create and run rest server\n      let debugPort = this.litenode.debugPort;\n      createRestServer(this).listen(debugPort);\n      console.log(`Debugging RESTful API server listening on port ${debugPort}.`);\n    }\n\n    // protocol handling setup is ready now\n    this.emit('ready');\n  }\n\n  /**\n   * If the given litemessage id is in LevelDB's litemessage index.\n   */\n  async hasLitemsg(litemsgId) {\n    return await this.litestore.hasLitemsg(litemsgId);\n  }\n\n  async invHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      // Note the \"blocks\" here either is a single block just\n      // mined by peer, or is a sub blockchain, which, in\n      // other words, means those blocks are consecutive.\n      // This is just due to how the protocol is designed.\n      let { blocks } = payload;\n      let blocksToGet = [];\n\n      // Filter out blocks already have (blocks off main branch \n      // still as being haven). Also note that those blocks haven\n      // by the current node, if any, must always certainly reside\n      // at the beginning of received `inv`'s blockchain. Again,\n      // this is just due to how the protocol is designed.\n      for (let blockId of blocks) {\n        if (!(await this.blockchain.hasBlock(blockId, false))) {\n          blocksToGet.push(blockId);\n        }\n      }\n\n      if (blocksToGet.length) {\n        peer.sendJson(\n          getHeaders({ blocks: blocksToGet })\n        );\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async headersHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      // `blocks` is only header (don't have body)\n      let { blocks } = payload;\n\n      // filter out invalid blocks (headers)\n      blocks = blocks.filter(block => verifyHeader(block));\n      blocks.sort((a, b) => a.height - b.height);\n\n      let headBlockId = this.blockchain.getHeadBlockIdSync();\n\n      if (blocks.length && blocks[blocks.length - 1].height > this.blockchain.getCurHeightSync()) {\n        if (blocks.length === 1) {\n          let block = blocks[0];\n\n          if (block.prevBlock === headBlockId) {\n            this.blockchain.append(block);\n          } else {\n            let blockLocators = this.blockchain.getLocatorsSync();\n            peer.sendJson(getBlocks({ blockLocators }));\n          }\n        } else {\n          // Note that `prevBlockId` and `prevBlock` down below refer to same block.\n          // Later, they will be used for traversing backward along the blockchain.\n          let prevBlockId = blocks[0].prevBlock;\n          let prevBlock = prevBlockId ? \n            (await this.blockchain.getBlock(prevBlockId)) : \n            undefined;\n\n          if (verifyHeaderChain(blocks, prevBlock)) {\n            // For efficiency, node doesn't fetch blocks on forked branch which it already \n            // has. The `litemsg_${litemsg_id}` of these mentioned blocks might be records\n            // on the main branch (before appending). So here, suppose the previous\n            // block of appended blocks is not on main branch, we need to extend from\n            // the appended blocks backwards to until a block which is on the main \n            // branch, or until the genesis block (of the forked branch), whichever reaches\n            // first. And then rewrite all `litemsg_${litemsg_id}` records so that all \n            // litemessages are correctly indexed after switching to another branch.\n\n            let extendedBlocks = [];\n\n            while (prevBlockId && !this.blockchain.onMainBranchSync(prevBlockId)\n              && headBlockId === this.blockchain.getHeadBlockIdSync()) {\n\n              extendedBlocks.unshift(prevBlock);\n\n              prevBlockId = prevBlock.prevBlock;\n              prevBlock = prevBlockId ?\n                (await this.blockchain.getBlock(prevBlockId)) :\n                undefined;\n            }\n\n            if (headBlockId === this.blockchain.getHeadBlockIdSync()) {\n              // switch the blockchain to another branch,\n              // for efficiency, don't await it finishing\n              // (no await here)\n              this.blockchain.appendAt([...extendedBlocks, ...blocks]);\n            }\n          }\n        }\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  peerConnectHandler(peer) {\n    if (peer.nodeType === 'full' && this.node.peers('full').length === 1) {\n      // wait for 30 seconds to retrieve blocks\n      // because of concorrent resolving (it takes\n      // time to construct connections with peers)\n      setTimeout(() => {\n        let blockLocators = this.blockchain.getLocatorsSync();\n        peer.sendJson(getBlocks({ blockLocators }));\n      }, 60000);\n    }\n\n    // TODO\n    // peer._resolver = new InventoryResolver(peer, this);\n  }\n\n  close() {\n    this.handshake.close();\n    super.close();\n  }\n}\n\nmodule.exports = ThinLiteProtocol;\n","const P2PProtocolStore = require('./store');\nconst {\n  messageTypes, messageValidators, fetchPeers, returnPeers\n} = require('./messages');\nconst { pickItems } = require('../utils/common');\n\nif (BUILD_TARGET === 'node') {\n  // running in node\n\n  var EventEmitter = require('events');\n  var { URL } = require('url');\n  var dns = require('dns');\n  var { promisify } = require('util');\n\n  // look up dns records\n  var lookup = promisify(dns.lookup);\n\n} else {\n  // running in browser\n\n  var EventEmitter = require('wolfy87-eventemitter');\n}\n\n/**\n * A abstract peer-to-peer protocol. You should NOT bind this protocol directly to \n * an implementation of node client. Instead, you should extend this protocol.\n * \n * NOTE all subclass implementations MUST emit a `ready` event (a protocol is also\n * an event emitter).\n * \n * NOTE the `nodeTypes` option, which specifies the types of node to connect automatically\n * when connecting to few of these types of node. The threshold is set by `minPeerNum`\n * option. The connected peers will also be persisted. When node is restarted, it will\n * reconnect those peristed peers.\n * \n * NOTE if you don't explicitly provde `nodeTypes` option, then it won't have any\n * auto-connecting feature as well as the feature of auto peer persistance.\n */\nclass P2PProtocol extends EventEmitter {\n  /**\n   * @param {*} node      full node, thin node, or...\n   * @param {*} options\n   *            nodeTypes nodeTypes node types to which a node will try to establish connection\n   *                      automatically. For instance, you want to maintain connected\n   *                      `full` nodes at least with a specific number, but you don't\n   *                      care how many `thin` nodes are connected. So you should only\n   *                      give `full` here, instead of both.\n   *           minPeerNum the minimal number of peers of type specified by `nodeTypes`\n   */\n  constructor(node, { nodeTypes = [], minPeerNum = 8 } = {}) {\n    super();\n\n    if (new.target === P2PProtocol) {\n      throw new TypeError(\"Cannot construct P2PProtocol instances directly.\");\n    }\n\n    this.persistPeerUrls = this.persistPeerUrls.bind(this);\n    this.fetchPeersHandler = this.fetchPeersHandler.bind(this);\n    this.returnPeersHandler = this.returnPeersHandler.bind(this);\n\n    this.node = node;\n    this.litenode = node.litenode;\n\n    this.intervalTimers = [];\n    this.store = new P2PProtocolStore(node.db);\n    \n    this.nodeTypes = nodeTypes;\n    this.minPeerNum = minPeerNum;\n\n    // register message handlers\n    this.litenode.on(`message/${messageTypes['fetchPeers']}`, this.fetchPeersHandler);\n    this.litenode.on(`message/${messageTypes['returnPeers']}`, this.returnPeersHandler);\n\n    if (nodeTypes.length) {\n      this.connectToLastConnectedPeers();\n\n      // periodically fetch more peers of given node types\n      this.intervalTimers.push(\n        setInterval(() => {\n          if (this.node.peers(nodeTypes).length < minPeerNum) {\n            this.litenode.broadcastJson(fetchPeers({ nodeTypes }));\n          }\n        }, 40000)\n      );\n\n      // periodically persist peer urls\n      this.intervalTimers.push(\n        setInterval(this.persistPeerUrls, 120000)\n      );\n    }\n  }\n\n  async connectToLastConnectedPeers() {\n    try {\n      let initUrls = this.node.initPeerUrls;\n      // initial peer urls can be hostnames, so perform dns queries first\n      let addresses = await Promise.all(\n        initUrls.map(url => lookup(new URL(url).hostname, { family: 4 }))\n      );\n\n      initUrls = initUrls.map((url, i) => {\n        url = new URL(url);\n        url.hostname = addresses[i].address\n        return url.toString().replace(/\\/$/, '');\n      });\n\n      (await this.store.readCurPeerUrls())\n        .filter(url => !initUrls.includes(url))\n        .forEach(url => this.litenode.createConnection(url));\n\n    } catch (err) {\n      console.error(err);\n      process.exit(1);\n    }\n  }\n\n  async persistPeerUrls() {\n    try {\n      let peerUrls = this.node.peers(this.nodeTypes)\n        .map(peer => peer.url);\n      await this.store.writeCurPeerUrls(peerUrls);\n    } catch (err) {\n      console.error(err);\n    }\n  }\n\n  fetchPeersHandler({ messageType, ...payload }, peer) {\n    try {\n      // validate the received message\n      messageValidators[messageType](payload);\n      \n      let { nodeTypes, limit } = payload;\n      let connectedPeerUrls = this.node.peers(nodeTypes)\n        .map(peer => peer.url);\n      if (connectedPeerUrls.includes(peer.url)) {\n        connectedPeerUrls.splice(connectedPeerUrls.indexOf(peer.url), 1);\n      }\n      let peerUrls = pickItems(connectedPeerUrls, limit);\n      let resMsg = returnPeers({ nodeTypes, peerUrls });\n      peer.sendJson(resMsg);\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  returnPeersHandler({ messageType, ...payload }, peer) {\n    try {\n      // validate the received message\n      messageValidators[messageType](payload);\n      \n      let { nodeTypes, peerUrls } = payload;\n      let connectedPeerUrls = this.node.peers(nodeTypes)\n        .map(peer => peer.url);\n      peerUrls.filter(url => !connectedPeerUrls.includes(url))\n        .forEach(url => this.litenode.createConnection(url));\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  close() {\n    this.removeAllListeners();\n    this.intervalTimers.forEach(t => clearInterval(t));\n  }\n}\n\nmodule.exports = P2PProtocol;\n","module.exports = require(\"path\");","const prefix = 'lite/';\n\nconst genKey = key => prefix + key;\n\nclass LiteProtocolStore {\n  constructor(db) {\n    this.db = db;\n  }\n\n  static get genKey() {\n    return genKey;\n  }\n\n  // async writeHeadBlock(blockId) {\n  //   return this.db.put(genKey('head_block'), blockId);\n  // }\n\n  /**\n   * Note that we don't index litemessage's content, which is part of a block.\n   * So in order to get the content of a litemessage, you must get the the block\n   * where the given litemessage resides first.\n   * \n   * This function return the block id (no matter the block in the main branch or\n   * not) where the given litemessage resides, or undefined if we don't have the\n   * litemessage in any block.\n   */\n  async readLitemsg(litemsgId) {\n    try {\n      let buf = await this.db.get(genKey(`litemsg_${litemsgId}`));\n      return buf.toString();\n\n    } catch (err) {\n      if (err.notFound) { return undefined; }\n      throw err;\n    }\n  }\n\n  async removeLitemsg(litemsgId) {\n    return this.db.del(genKey(`litemsg_${litemsgId}`));\n  }\n\n  /**\n   * TODO might change this: we don't need to have index for litemessages?\n   * might just litemessage's location index (in which block).\n   */\n  // async writeLitemsg(litemsg) {\n  //   if (typeof litemsg.hash !== 'string') {\n  //     throw new Error('Invalid litemessage hash.');\n  //   }\n  //   return this.db.put(genKey(`litemsg_${litemsg.hash}`), litemsg);\n  // }\n\n  async hasLitemsg(litemsgId) {\n    return (await this.readLitemsg(litemsgId)) !== undefined;\n  }\n\n  // following is block-related ...\n\n  /**\n   * Return the head block's **id** (or undefined when there's no\n   * block in the blockchain)\n   */\n  async readHeadBlock() {\n    try {\n      let buf = await this.db.get(genKey('head_block'));\n      return buf.toString();\n    } catch (err) {\n      if (err.notFound) { return undefined; }\n      throw err;\n    }\n  }\n\n  // async writeBlock(block) {\n  //   if (typeof block.hash !== 'string') {\n  //     throw new Error('Invalid block hash.');\n  //   }\n  //   return this.db.put(genKey(`block_${block.hash}`), block);\n  // }\n\n  /**\n   * Return the whole block specified by the given block id.\n   * If block doesn't exist, `undefined` will be returned.\n   */\n  async readBlock(blockId) {\n    try {\n      let buf = await this.db.get(genKey(`block_${blockId}`));\n      return JSON.parse(buf.toString());\n      \n    } catch (err) {\n      if (err.notFound) { return undefined; }\n      throw err;\n    }\n  }\n\n  /**\n   * Append one more block on top of the current head block.\n   */\n  async appendBlock(block, batchOps) {\n    if (typeof block.hash !== 'string') {\n      throw new Error('Invalid block hash.');\n    }\n\n    let ops = [\n      { type: 'put', key: genKey(`block_${block.hash}`), value: JSON.stringify(block) },\n      { type: 'put', key: genKey('head_block'), value: block.hash }\n    ];\n    if (block.litemsgs) {\n      for (let litemsg of block.litemsgs) {\n        ops.push({ type: 'put', key: genKey(`litemsg_${litemsg.hash}`), value: block.hash });\n      }\n    }\n    if (batchOps) {\n      ops = [...ops, ...batchOps];\n    }\n\n    return this.db.batch(ops);\n  }\n\n  /**\n   * Sometimes forks could happen. Call this to switch to\n   * another fork.\n   * \n   * @param {*} blocks  blocks from another branch to switch\n   */\n  async appendBlocksAt(blocks, batchOps) {\n    if (!blocks.length) { return; }\n\n    let headBlock = blocks[blocks.length - 1];\n    let ops = [];\n\n    for (let block of blocks) {\n      if (typeof block.hash !== 'string') { throw new Error('Invalid block hash.'); }\n\n      ops.push({ type: 'put', key: genKey(`block_${block.hash}`), value: JSON.stringify(block) });\n      if (block.litemsgs) {\n        for (let litemsg of block.litemsgs) {\n          ops.push({ type: 'put', key: genKey(`litemsg_${litemsg.hash}`), value: block.hash });\n        }\n      }\n    }\n    ops.push({ type: 'put', key: genKey('head_block'), value: headBlock.hash });\n\n    if (batchOps) { ops = [...ops, ...batchOps]; }\n\n    return this.db.batch(ops);\n  }\n}\n\nmodule.exports = LiteProtocolStore;\n","const Peer = require('../peer');\nconst {\n  messageValidators, info, infoAck,\n  messageTypes: { info: infoType, infoAck: infoAckType }\n} = require('./messages');\nconst { getCurTimestamp } = require('../utils/time');\nconst { getSocketAddress } = require('../utils/network');\n\nif (BUILD_TARGET === 'node') {\n  // running in node\n\n  var EventEmitter = require('events');\n\n} else {\n  // running in browser\n\n  var EventEmitter = require('wolfy87-eventemitter');\n}\n\n// ********************* requiring ends *********************\n\n// allowed message types during handshake\nconst MSG_TYPES = [infoType, infoAckType];\n\nclass PendingSocket {\n  constructor(socket, incoming) {\n    // the pending socket itself\n    this.socket = socket;\n\n    // inbound or outbound\n    this.incoming = incoming;\n\n    // 'INIT'\n    // 'INFO_SENT'\n    // 'ESTABLISHED'\n    this.state = 'INIT';\n\n    // the timestamp when socket is created\n    this.timestamp = getCurTimestamp();\n\n    // remote info\n    this.uuid = undefined;\n    this.nodeType = undefined;\n    this.daemonPort = undefined;\n  }\n}\n\nclass HandshakeManager extends EventEmitter {\n  constructor(p2pProtocol) {\n    super();\n    this.socketConnectHandler = this.socketConnectHandler.bind(this);\n\n    this.litenode = p2pProtocol.litenode;\n    this.uuid = p2pProtocol.litenode.uuid;\n    this.nodeType = p2pProtocol.node.nodeType;\n    this.daemonPort = p2pProtocol.litenode.daemonPort;\n\n    // sockets => pending sockets (which is a wrapper)\n    this.pendingSockets = new Map();\n\n    // listen on new socket connection\n    this.litenode.on('socketconnect', this.socketConnectHandler);\n\n    // in case too many pending connections (such as DDoS),\n    // drop pending connections after roughly 20s' idle\n    this.timer = setInterval(() => {\n      let now = getCurTimestamp();\n      for (let [socket, pendingSocket] of this.pendingSockets) {\n        if (now - pendingSocket.timestamp > 20000) {\n          console.warn(`Handshake timeouts with ${getSocketAddress(socket)}.`);\n          socket.close(undefined, 'HANDSHAKE_TIMEOUTS');\n          this.pendingSockets.delete(socket);\n        }\n      }\n\n    }, 10000);\n  }\n\n  addPendingSocket(socket, incoming) {\n    try {\n      let pendingSocket = new PendingSocket(socket, incoming);\n      let proxiedSocket = this.litenode.createSocketProxy(socket, 'N/A');\n\n      socket._messageHandler = ((message) => {\n        try {\n          let { state } = pendingSocket\n          let { messageType, ...payload } = JSON.parse(message);\n          if (typeof messageType !== 'string' || !MSG_TYPES.includes(messageType)) {\n            throw new Error();\n          }\n\n          if (this.litenode.debug) {\n            // note that only logs valid procotol messages\n            this.litenode.messageLogs.push({\n              peer: 'N/A',\n              dir: 'inbound',\n              msg: { messageType, ...payload },\n              time: getCurTimestamp('s')\n            });\n          }\n          \n          // when receiving info message\n          if (messageType === infoType) {\n            messageValidators[infoType](payload);\n  \n            if (incoming && state === 'INIT') {\n              pendingSocket.state = 'INFO_SENT'\n              pendingSocket.uuid = payload.uuid;\n              pendingSocket.nodeType = payload.nodeType;\n              pendingSocket.daemonPort = payload.daemonPort;\n  \n              this.sendInfo(proxiedSocket);\n  \n            } else if (!incoming && state === 'INFO_SENT') {\n              pendingSocket.state = 'ESTABLISHED';\n              pendingSocket.uuid = payload.uuid;\n              pendingSocket.nodeType = payload.nodeType;\n              pendingSocket.daemonPort = payload.daemonPort;\n  \n              this.sendInfoAck(proxiedSocket);\n              this.onEstablished(pendingSocket);\n  \n            } else {\n              throw new Error();\n            }\n          }\n  \n          // when receiving info ack message\n          if (messageType === infoAckType) {\n            messageValidators[infoAckType](payload);\n  \n            if (incoming && state === 'INFO_SENT') {\n              pendingSocket.state = 'ESTABLISHED';\n  \n              this.onEstablished(pendingSocket);\n  \n            } else {\n              throw new Error();\n            }\n          }\n  \n        } catch (err) {\n          console.warn(`Handshake failed with ${getSocketAddress(socket)}, reason:\\n${err.stack}`);\n          // close the underlying socket\n          socket.close(undefined, 'HANDSHAKE_FAILED');\n        }\n\n      }).bind(this); // end of _messageHandler\n\n      socket.on(BUILD_TARGET === 'node' ? 'message' : 'data', socket._messageHandler);\n      socket.on('close', (code, reason) => {\n        this.pendingSockets.delete(socket);\n      });\n      this.pendingSockets.set(socket, pendingSocket);\n\n      if (!incoming) {\n        // sending the first info message\n        // to initiate the handshake process\n        this.sendInfo(proxiedSocket);\n        pendingSocket.state = 'INFO_SENT'\n      }\n\n    } catch (err) {\n      console.warn(`Handshake failed with ${getSocketAddress(socket)}, reason:\\n${err}`);\n      // close the underlying socket\n      socket.close(undefined, 'HANDSHAKE_FAILED');\n    }\n  }\n\n  socketConnectHandler(socket, incoming) {\n    this.addPendingSocket(socket, incoming);\n  }\n\n  // on handshake completing\n  onEstablished(pendingSocket) {\n    let { socket, incoming, uuid, nodeType, daemonPort } = pendingSocket;\n    let peer = new Peer(uuid, socket, incoming, daemonPort, nodeType);\n\n    socket.removeListener('message', socket._messageHandler);\n    delete socket._messageHandler\n    \n    this.pendingSockets.delete(socket);\n    this.litenode.addNewPeer(peer);\n  }\n\n  sendInfo(socket) {\n    socket.send(JSON.stringify(info({\n      uuid: this.uuid, \n      nodeType: this.nodeType,\n      daemonPort: this.daemonPort\n    })));\n  }\n\n  sendInfoAck(socket) {\n    socket.send( JSON.stringify(infoAck()) );\n  }\n\n  /**\n   * Do the cleanup.\n   */\n  close() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n  }\n}; // end of HandshakeManager\n\nmodule.exports = HandshakeManager;\n","const EventEmitter = require('events');\n\n/**\n * A chunk is a fixed number of consecutive blocks (only block id) grouped\n * together stored in LevelDB in binary format (not in hex encode), mainly\n * for retrieval / flushing efficiency from or to disk.\n * \n * NOTE that once a block is stored in LevelDB, you should NEVER change this\n * constant down below. Otherwise, data will be corrupted.\n */\nconst chunkSize = 1024;\n\n/**\n * This is a very low level abstraction of a blockchain, which needs to be \n * injected with an store (using LevelDB / IndexedDB) interface implementation\n * for interacting with persistant storage medium. Take `LiteProtocol`'s\n * implementation as an example.\n * \n * This blockchain abstraction here is (should) be protocol-agnostic.\n * \n * One assumption using this blockchain abstraction here is that you MUST \n * always only persist valid blocks (it doesn't have to be in the main branch \n * in the long run, but it must be a valid block). And you append elder blocks \n * and then newer blocks to the blockchain, either one by one, or in a batch.\n * In other words, you MUST always append a block after all its predecessor blocks\n * have been persisted.\n * \n * NOTE that both chunk and height (length of blockchain) start at index 0.\n */\nclass Blockchain extends EventEmitter {\n  constructor(store) {\n    super();\n    this.store = store;\n    this.db = store.db;\n    this.genKey = store.constructor.genKey;\n    \n    // an array of block ids (in hex encoding)\n    this.blockchain = null;\n    this._ready = false;\n\n    this.init();\n  }\n\n  get ready() {\n    return this._ready;\n  }\n\n  async init() {\n    try {\n      let height = await this.getCurHeight() + 1;\n      let numOfChunks = Math.floor(height / chunkSize);\n      let numOfBlocks = height % chunkSize;\n\n      let chunks = await Promise.all(\n        Array.from(Array(numOfChunks).keys()) // generate a number sequence\n          .map(num => this._getChunk(num))\n      );\n      // flatten chunks\n      chunks = [].concat.apply([], chunks);\n\n      let blocks = [];\n      let prevBlockId = null;\n      for (let i = 0; i < numOfBlocks; i++) {\n        let block = await (\n          i === 0 ? this.getHeadBlock() : this.getBlock(prevBlockId)\n        );\n\n        prevBlockId = block.prevBlock;\n        blocks.unshift(block.hash);\n      }\n\n      this.blockchain = [...chunks, ...blocks];\n      this._ready = true;\n      this.emit('ready');\n\n    } catch (err) {\n      this.emit('error', err);\n    }\n  }\n\n  /**\n   * Inside a chunk, the order is from elder blocks to newer blocks.\n   * Note that if you're trying to get a non-existent chunk, an error\n   * will be thrown.\n   */\n  async _getChunk(serialNum) {\n    let buf = await this.db.get(this.genKey(`chunk_${serialNum}`));\n    let chunk = [];\n\n    // just be cautious\n    if (buf.length !== chunkSize * 32) { process.exit(1); }\n\n    for (let i = 0; i < buf.length; i += 32) {\n      chunk.push(buf.slice(i, i + 32).toString('hex'));\n    }\n    return chunk;\n  }\n\n  /**\n   * Append next block on top of current head block on the blockchain.\n   */\n  async append(block) {\n    const ops = [];\n    this.blockchain.push(block.hash);\n    let height = this.getCurHeightSync();\n\n    if ((height + 1) % chunkSize === 0) {\n      const serialNum = Math.floor((height + 1) / chunkSize) - 1;\n      const buf = Buffer.from(this.blockchain.slice(height + 1 - chunkSize).join(''), 'hex');\n      ops.push({ type: 'put', key: this.genKey(`chunk_${serialNum}`), value: buf });\n    }\n\n    return this.store.appendBlock(block, ops);\n  }\n\n  /**\n   * Append a branch on a specific location on the blockchain, and the \n   * new branch will be the main blockchain branch.\n   * \n   * TODO update chunk index\n   */\n  async appendAt(blocks) {\n    // some cautious checks\n    if (!blocks.length) { return; }\n    if (blocks[blocks.length - 1].height <= this.getCurHeightSync()) {\n      throw new Error('Trying to append a invalid subchain, abort.');\n    }\n\n    let at = blocks[0].height;\n    let blockIds = blocks.map(block => block.hash);\n    let offBlockIds = this.blockchain.splice(at, Number.MAX_SAFE_INTEGER, ...blockIds);\n\n    let chunkAt = Math.floor(at / chunkSize);\n    let ops = [];\n\n    for (let i = chunkAt * chunkSize; i + chunkSize < this.blockchain.length; i += chunkSize) {\n      let buf = Buffer.from(this.blockchain.slice(i, i + chunkSize).join(''), 'hex');\n      ops.push({ type: 'put', key: this.genKey(`chunk_${i / chunkSize}`), value: buf });\n    }\n\n    // append the new branch\n    await this.store.appendBlocksAt(blocks, ops);\n\n    // following removes stale litemessage indices\n    let offBlocks = await Promise.all(\n      offBlockIds.map(id => this.getBlock(id))\n    );\n    let offLitemsgs = [];\n\n    for (let block of offBlocks) {\n      if (block.litemsgs) {\n        offLitemsgs.push(...block.litemsgs);\n      }\n    }\n    await Promise.all(\n      offLitemsgs.map(async ({ hash }) => {\n        let blockId = await this.store.readLitemsg(hash);\n\n        if (!this.onMainBranchSync(blockId)) {\n          return this.store.removeLitemsg(hash);\n        }\n      })\n    );\n    // resolve nothing when success\n    // reject with error when error\n  }\n\n  /**\n   * Return the head block, or `undefined` when there's no\n   * block on the blockchain.\n   */\n  async getHeadBlock() {\n    let blockId = await this.store.readHeadBlock();\n    return this.getBlock(blockId);\n  }\n\n  /**\n   * Synchronously get current head block's id. If there is no block\n   * yet, `undefined` will be returned.\n   */\n  getHeadBlockIdSync() {\n    let length = this.blockchain.length;\n    return length ? this.blockchain[length - 1] : undefined;\n  }\n\n  getBlockIdAtSync(height) {\n    let curHeight = this.getCurHeightSync();\n    if (height < 0 || height > curHeight) {\n      throw new Error('Invalid height given.');\n    }\n\n    return this.blockchain[height];\n  }\n\n  /**\n   * Note that height is 0-based (first block's height is 0).\n   * If there's no block yet, `-1` will returned.\n   */\n  async getCurHeight() {\n    let block = await this.getHeadBlock();\n    return block ? block.height : -1;\n  }\n\n  /**\n   * Note that height is 0-based (first block's height is 0).\n   * If there's no block yet, `-1` will returned.\n   */\n  getCurHeightSync() {\n    return this.blockchain.length - 1;\n  }\n\n  /**\n   * Get a list of block locator hashes, which is used in the\n   * `getBlocks` message that typically exists in blockchain\n   * protocol.\n   */\n  getLocatorsSync() {\n    let locators = [];\n    let height = this.getCurHeightSync();\n    let pow = 0;\n\n    if (height === -1) { return []; }\n\n    while (true) {\n      let i = Math.max(height + 1 - Math.pow(2, pow), 0);\n      locators.push(this.getBlockIdAtSync(i));\n      if (i === 0) { break; }\n      pow += 1;\n    }\n    return locators;\n  }\n\n  /**\n   * Get forked branch based on locators (an array of block hashes) peer provides.\n   * Return an array of block ids (from elder blocks to latest ones).\n   */\n  getForkedBranchSync(locators) {\n    if (this.blockchain.length < locators.length) {\n      return [];\n    }\n\n    let height = this.getCurHeightSync();\n    if (height === -1) { return []; }\n    let i = height;\n\n    for (; i >= 0; i--) {\n      let blockId = this.blockchain[i];\n      if (locators.includes(blockId)) {\n        break;\n      }\n    }\n\n    if (i === height) { return []; }\n    return this.blockchain.slice(i + 1);\n  }\n\n  /**\n   * @param {*} height note that height is 0-based index\n   */\n  async getBlockAt(height) {\n    // just to be cautious\n    if (height >= this.blockchain.length) {\n      throw new Error('Invalid block height.');\n    }\n\n    let blockId = this.blockchain[height];\n    return this.getBlock(blockId);\n  }\n\n  /**\n   * Get all blocks on the blockchain main branch.\n   * At this point there is no pagination yet, so this\n   * operation is very expensive.\n   */\n  async getBlocks(reverse = true) {\n    let blocks = await Promise.all(\n      this.blockchain.map(this.getBlock, this)\n    );\n    if (reverse) { blocks.reverse(); }\n    return blocks;\n  }\n\n  /**\n   * Return the whole block specified by the given block id.\n   * If block doesn't exist, `undefined` will be returned.\n   */\n  async getBlock(blockId) {\n    return this.store.readBlock(blockId);\n  }\n\n  /**\n   * If the given block is not on the main blockchain, the confirmation\n   * count will always be 0.\n   */\n  getConfirmationCntSync(blockId) {\n    if (!this.onMainBranchSync(blockId)) { return null; }\n\n    return this.getCurHeightSync() - this.blockchain.indexOf(blockId);\n  }\n\n  /**\n   * Determine whether the given block is on the main blockchain branch.\n   * The difference from the func `hasBlock` is that this is a synchronous\n   * operation.\n   */\n  onMainBranchSync(blockId) {\n    return this.blockchain.includes(blockId);\n  }\n\n  /**\n   * By default, return true only if the given block is on the main blockchain\n   * branch. If you want it to return true even if the block is off main branch,\n   * set the `onMainBranch` to false.\n   */\n  async hasBlock(blockId, onMainBranch = true) {\n    if (onMainBranch) {\n      return this.blockchain.includes(blockId);\n    }\n\n    return await this.getBlock(blockId) !== undefined;\n  }\n}\n\nmodule.exports = Blockchain;\n","const http = require('http');\nconst express = require('express');\nconst logger = require('morgan');\nconst cookieParser = require('cookie-parser');\nconst bodyParser = require('body-parser');\nconst { isValidJson, parseChunk } = require('../utils/common');\n\nconst notfoundPayload = { 'not-found': true };\n\n/**\n * filter log entries\n */\nfunction logFilter(logs, { peer, dir, type, since }) {\n  return logs.filter(log => (\n    (!peer || log.peer.startsWith(peer))\n    && (!dir || log.dir.startsWith(dir))\n    && (!type || log.msg.messageType.startsWith(type))\n    && (!since || log.time > since)\n  ));\n}\n\n/**\n * create a very minimalist rest server for debugging\n */\nfunction createRestServer(liteProtocol) {\n  const app = express();\n  const node = liteProtocol.node;\n  const litenode = liteProtocol.litenode;\n  const blockchain = liteProtocol.blockchain;\n  const litestore = liteProtocol.litestore;\n  const leveldb = liteProtocol.litestore.db;\n\n  app.use(logger('dev'));\n  app.use(cookieParser());\n  app.use(bodyParser.json());\n  app.use(bodyParser.urlencoded({ extended: false }));\n\n  app.get('/', (req, res) => {\n    res.status(200).json({\n      endpoints: [\n        { '/info': 'all sorts of info about this node' },\n        { '/peers': 'peer information' },\n        { '/msgpool': 'pending litemessage pool' },\n        { '/blocks': 'get all blocks on the main branch' },\n        { '/blocks/:blockId': 'get specified block' },\n        { '/litemsgs/:litemsgId': 'get a litemessage\\'s info on blockchain' },\n        { '/logs': 'protocol message logs' },\n        { '/litedb/:key': 'fetch any leveldb value of a given key' },\n        { '/locators': 'get the block locator hashes' }\n      ]\n    });\n  });\n\n  app.get('/info', (req, res) => {\n    res.status(200).json(litenode.getInfo());\n  });\n\n  app.get('/peers', (req, res) => {\n    let { type } = req.query;\n    res.status(200).json(node.peers(type));\n  });\n\n  app.get('/msgpool', (req, res) => {\n    res.status(200).json(liteProtocol.litemsgPool);\n  });\n\n  app.get('/blocks', async (req, res) => {\n    let blocks = await blockchain.getBlocks();\n\n    let { simple } = req.query;\n    if (simple && simple.toLowerCase() === 'true') {\n      blocks = blocks.map(block => ({ [block.height]: block.hash }));\n    }\n\n    res.status(200).json(blocks);\n  });\n\n  app.get('/blocks/:blockId', async (req, res, next) => {\n    try {\n      let { blockId } = req.params;\n      let block = await liteProtocol.blockchain.getBlock(blockId);\n\n      if (block) {\n        res.status(200).json(block);\n      } else {\n        res.status(404).json(notfoundPayload);\n      }\n\n    } catch (err) {\n      next(err);\n    }\n  });\n\n  app.get('/litemsgs/:litemsgId', async (req, res, next) => {\n    try {\n      let { litemsgId } = req.params;\n      let at = await litestore.readLitemsg(litemsgId);\n\n      if (typeof at === 'undefined') {\n        res.status(404).json(notfoundPayload);\n        return;\n      }\n\n      let mainBranch = blockchain.onMainBranchSync(at);\n      let confirmation = mainBranch ?\n        blockchain.getConfirmationCntSync(at) :\n        'N/A';\n      \n      res.status(200).json({ at, mainBranch, confirmation });\n\n    } catch (err) {\n      next(err);\n    }\n  });\n\n  app.get('/logs', (req, res) => {\n    let logs = liteProtocol.litenode.messageLogs;\n    let { peer, dir, type, since } = req.query;\n    if (typeof since === 'string') {\n      since = parseInt(since);\n    }\n\n    res.status(200).json(logFilter(logs, { peer, dir, type, since }));\n  });\n\n  app.get('/litedb/:key', async (req, res, next) => {\n    try {\n      let { key } = req.params;\n      let buf = await leveldb.get('lite/' + key);\n      let str = key.startsWith('chunk_') ?\n        JSON.stringify(parseChunk(buf)) :\n        buf.toString();\n\n      let payload = isValidJson(str) ? JSON.parse(str) : { _$: str };\n      res.status(200).json(payload);\n\n    } catch (err) {\n      if (err.notFound) {\n        res.status(404).json(notfoundPayload);\n      } else {\n        next(err);\n      }\n    }\n  });\n\n  app.get('/locators', (req, res) => {\n    let locators = blockchain.getLocatorsSync();\n    res.status(200).json(locators);\n  });\n\n  return http.createServer(app);\n}\n\nmodule.exports = createRestServer;\n","const P2PProtocol = require('../p2pprotocol/p2protocol');\nconst LiteProtocolStore = require('./store');\nconst Miner = require('./miner');\nconst Blockchain = require('../utils/blockchain');\nconst HandshakeManager = require('./handshake');\nconst InvResolveHandler = require('./resolv-handler');\nconst InventoryResolver = require('./inv-resolv');\nconst createRestServer = require('./rest');\nconst createBlock = require('./entities/block');\nconst {\n  messageTypes, messageValidators, getBlocks, \n  inv, data, getPendingMsgs, headers, \n  litemsgLocators\n} = require('./messages');\nconst {\n  verifyBlock, verifyLitemsg, calcMerkleRoot, verifySubchain\n} = require('../utils/litecrypto');\nconst { pickItems } = require('../utils/common');\nconst { getCurTimestamp } = require('../utils/time');\n\n// protcol version\nconst VERSION = 1;\n// mining difficulty\nconst BITS = 22;\n// block size limit\nconst BLOCK_LIMIT = 2048;\n// node types to re/connect automatically\nconst AUTO_CONN_NODE_TYPES = ['full'];\n\n/**\n * This is the actual litemessage protocol implementation\n * for \"full\" nodes.\n */\nclass LiteProtocol extends P2PProtocol {\n  static get ver() {\n    return VERSION;\n  }\n\n  constructor(node) {\n    super(node, { nodeTypes: AUTO_CONN_NODE_TYPES });\n    this.getBlocksHandler = this.getBlocksHandler.bind(this);\n    this.invHandler = this.invHandler.bind(this);\n    this.getDataHandler = this.getDataHandler.bind(this);\n    this.getHeadersHandler = this.getHeadersHandler.bind(this);\n    this.dataHandler = this.dataHandler.bind(this);\n    this.locateLitemsgsHandler = this.locateLitemsgsHandler.bind(this);\n    this.getPendingMsgsHandler = this.getPendingMsgsHandler.bind(this);\n    this.peerConnectHandler = this.peerConnectHandler.bind(this);\n\n    this.litestore = new LiteProtocolStore(node.db);\n    // a blockchain manager\n    this.blockchain = new Blockchain(this.litestore);\n    this.miner = new Miner();\n    // map litemessage id to litemessage itself (pending litemessages)\n    this.litemsgPool = {};\n\n    // wait for blockchain initializing itself\n    this.blockchain.on('ready', () => this.init());\n\n    this.blockchain.on('error', err => {\n      console.error(err);\n      process.exit(1);\n    });\n  }\n\n  init() {\n    // register message/connection handlers\n    this.litenode.on(`message/${messageTypes.getBlocks}`, this.getBlocksHandler);\n    this.litenode.on(`message/${messageTypes.inv}`, this.invHandler);\n    this.litenode.on(`message/${messageTypes.getData}`, this.getDataHandler);\n    this.litenode.on(`message/${messageTypes.getHeaders}`, this.getHeadersHandler);\n    this.litenode.on(`message/${messageTypes.data}`, this.dataHandler);\n    this.litenode.on(`message/${messageTypes.locateLitemsgs}`, this.locateLitemsgsHandler);\n    this.litenode.on(`message/${messageTypes.getPendingMsgs}`, this.getPendingMsgsHandler);\n    this.litenode.on('peerconnect', this.peerConnectHandler);\n\n    // instantiate a handshake manager so that\n    // our node can connect to other nodes : P\n    this.handshake = new HandshakeManager(this);\n    // this node supports inventory resolution : P\n    this.invResolvHandler = new InvResolveHandler(this);\n\n    if (this.litenode.debug) {\n      // create and run rest server\n      let debugPort = this.litenode.daemonPort + 1;\n      createRestServer(this).listen(debugPort);\n      console.log(`Debugging RESTful API server listening on port ${debugPort}.`);\n    }\n\n    // some schedule tasks (interval timers)\n    this.timers = [];\n\n    // schedule mining\n    this.timers.push(\n      setInterval(async () => {\n        if (!this.miner.mining && Object.entries(this.litemsgPool).length) {\n          this.mineNextBlock();\n        }\n\n      }, 1000)\n    );\n\n    // schedule getting pending messages\n    this.timers.push(\n      setInterval(() => {\n        if (Object.entries(this.litemsgPool).length > 0) { return; }\n\n        try {\n          pickItems(this.node.peers('full'), 8)\n            .forEach(peer => peer.sendJson(getPendingMsgs()))\n        } catch (err) { console.warn(err); }\n\n      }, 30000)\n    );\n\n    // protocol handling setup is ready now\n    this.emit('ready');\n  }\n\n  async getNextBlock() {\n    let time = getCurTimestamp();\n    let litemsgs = pickItems(Object.values(this.litemsgPool), BLOCK_LIMIT);\n    let merkleRoot = calcMerkleRoot(litemsgs.map(m => m.hash));\n    let { \n      height = -1, hash: prevBlock = undefined \n    } = await this.blockchain.getHeadBlock() || {};\n    height += 1;\n    \n    return createBlock(VERSION, time, height, prevBlock, merkleRoot, BITS, undefined, litemsgs);\n  }\n\n  async mineNextBlock() {\n    let block = await this.getNextBlock();\n    block = await this.miner.mine(block);\n    let headBlockId = this.blockchain.getHeadBlockIdSync();\n\n    if (!headBlockId || block.prevBlock === headBlockId) {\n      let now = getCurTimestamp();\n      let timeTaken = Math.round((now - block.time) / 1000);\n      console.log(`Successfully mined a new block (${timeTaken} s): ${block.hash}.`);\n\n      // append the mined block to blockchain\n      this.blockchain.append(block);\n\n      // remove from pending message pool\n      for (let litemsg of block.litemsgs) {\n        delete this.litemsgPool[litemsg.hash];\n      }\n\n      // broadcast to peers\n      this.litenode.broadcastJson(inv({ blocks: [block.hash] }));\n    }\n  }\n\n  /**\n   * After receiving blocks from a peer and verifying them, call this\n   * func to remove litemessages (if any) which exist in these blocks\n   * before appending them to the blockchain.\n   * \n   * @param {*} blocks blocks (already verified) received from a peer\n   */\n  cleanPoolAndRestartMining(blocks) {\n    for (let block of blocks) {\n      for (let litemsg of block.litemsgs) {\n        delete this.litemsgPool[litemsg.hash];\n      }\n    }\n\n    if (Object.entries(this.litemsgPool).length) {\n      this.mineNextBlock();\n    }\n  }\n\n  inLitemsgPool(litemsgId) {\n    return !!this.litemsgPool[litemsgId];\n  }\n\n  /**\n   * If the given litemessage id is in LevelDB's litemessage index\n   * or it's in the pending pool, the return value will be `true`.\n   */\n  async hasLitemsg(litemsgId) {\n    return (await this.litestore.hasLitemsg(litemsgId))\n      || this.inLitemsgPool(litemsgId);\n  }\n\n  async getBlocksHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { blockLocators } = payload;\n      let forkedBranch = this.blockchain.getForkedBranchSync(blockLocators);\n\n      if (forkedBranch.length) {\n        // send response based on received locators\n        peer.sendJson(inv({ blocks: forkedBranch }));\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async invHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      // Note the \"blocks\" here either is a single block just\n      // mined by peer, or is a sub blockchain, which, in\n      // other words, means those blocks are consecutive.\n      // This is just due to how the protocol is designed.\n      let { blocks, litemsgs } = payload;\n      let blocksToGet = [];\n      let litemsgsToGet = [];\n\n      // Filter out blocks already have (blocks off main branch \n      // still as being haven). Also note that those blocks haven\n      // by the current node, if any, must always certainly reside\n      // at the beginning of received `inv`'s blockchain. Again,\n      // this is just due to how the protocol is designed.\n      for (let blockId of blocks) {\n        if (!(await this.blockchain.hasBlock(blockId, false))) {\n          blocksToGet.push(blockId);\n        }\n      }\n\n      // filter out litemessages already have\n      for (let litemsgId of litemsgs) {\n        if (!(await this.hasLitemsg(litemsgId))) {\n          litemsgsToGet.push(litemsgId);\n        }\n      }\n\n      if (blocksToGet.length || litemsgsToGet.length) {\n        peer._resolver.resolve({\n          blocks: blocksToGet,\n          litemsgs: litemsgsToGet\n        });\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async getDataHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { blocks, litemsgs } = payload;\n      let respBlocks = null;\n      let respLitemsgs = [];\n\n      // give blocks no matter which branch they are on\n      respBlocks = await Promise.all(\n        blocks.map(blockId => this.blockchain.getBlock(blockId))\n      );\n      respBlocks = respBlocks.filter(block => typeof block !== 'undefined');\n\n      for (let litemsgId of litemsgs) {\n        // note only return litemessages from pool for `getData`\n        let litemsg = this.litemsgPool[litemsgId];\n        if (litemsg) { respLitemsgs.push(litemsg); }\n      }\n\n      if (respBlocks.length || respLitemsgs.length) {\n        // send response\n        peer.sendJson(\n          data({ blocks: respBlocks, litemsgs: respLitemsgs })\n        );\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async getHeadersHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { blocks } = payload;\n\n      // give blocks no matter which branch they are on\n      let respBlocks = (await Promise.all(\n          blocks.map(blockId => \n            this.blockchain.getBlock(blockId))\n        ))\n        .filter(block => typeof block !== 'undefined');\n\n      // strip off block bodies\n      for (let block of respBlocks) {\n        delete block['litemsgs'];\n      }\n\n      if (respBlocks.length) {\n        // send response\n        peer.sendJson(\n          headers({ blocks: respBlocks })\n        );\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  /**\n   * TODO sync pool and restart mining?\n   */\n  async dataHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { blocks, litemsgs } = payload;\n      let relayBlocks = []; // always 0 or 1 element\n      let relayLitemsgs = [];\n\n      // filter out invalid blocks and litemessages\n      blocks = blocks.filter(block => verifyBlock(block));\n      blocks.sort((a, b) => a.height - b.height);\n      litemsgs = litemsgs.filter(litemsg => verifyLitemsg(litemsg));\n\n      let headBlockId = this.blockchain.getHeadBlockIdSync();\n\n      if (blocks.length && blocks[blocks.length - 1].height > this.blockchain.getCurHeightSync()) {\n        if (blocks.length === 1) {\n          let block = blocks[0];\n\n          if (block.prevBlock === headBlockId) {\n            this.cleanPoolAndRestartMining(blocks);\n            this.blockchain.append(block);\n            relayBlocks.push(block);\n          } else {\n            let blockLocators = this.blockchain.getLocatorsSync();\n            peer.sendJson(getBlocks({ blockLocators }));\n          }\n        } else {\n          // Note that `prevBlockId` and `prevBlock` down below refer to same block.\n          // Later, they will be used for traversing backward along the blockchain.\n          let prevBlockId = blocks[0].prevBlock;\n          let prevBlock = prevBlockId ? \n            (await this.blockchain.getBlock(prevBlockId)) : \n            undefined;\n\n          if (verifySubchain(blocks, prevBlock)) {\n            // For efficiency, node doesn't fetch blocks on forked branch which it already \n            // has. The `litemsg_${litemsg_id}` of these mentioned blocks might be records\n            // on the main branch (before appending). So here, suppose the previous\n            // block of appended blocks is not on main branch, we need to extend from\n            // the appended blocks backwards to until a block which is on the main \n            // branch, or until the genesis block (of the forked branch), whichever reaches\n            // first. And then rewrite all `litemsg_${litemsg_id}` records so that all \n            // litemessages are correctly indexed after switching to another branch.\n\n            let extendedBlocks = [];\n\n            while (prevBlockId && !this.blockchain.onMainBranchSync(prevBlockId)\n              && headBlockId === this.blockchain.getHeadBlockIdSync()) {\n\n              extendedBlocks.unshift(prevBlock);\n\n              prevBlockId = prevBlock.prevBlock;\n              prevBlock = prevBlockId ?\n                (await this.blockchain.getBlock(prevBlockId)) :\n                undefined;\n            }\n\n            if (headBlockId === this.blockchain.getHeadBlockIdSync()) {\n              this.cleanPoolAndRestartMining(blocks);\n              // switch the blockchain to another branch,\n              // for efficiency, don't await it finishing\n              // (no await here)\n              this.blockchain.appendAt([...extendedBlocks, ...blocks]);\n            }\n          }\n        }\n      }\n\n      // process received litemessages\n      for (let litemsg of litemsgs) {\n        if (await this.hasLitemsg(litemsg.hash)) { continue; }\n\n        relayLitemsgs.push(litemsg.hash);\n        this.litemsgPool[litemsg.hash] = litemsg;\n      }\n\n      if (relayBlocks.length || relayLitemsgs.length) {\n        // relay (broadcast) data messaage\n        this.litenode.broadcastJson(\n          inv({ blocks: relayBlocks, litemsgs: relayLitemsgs }),\n          [peer.uuid]\n        );\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async locateLitemsgsHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { litemsgs } = payload;\n\n      let lookup = await Promise.all(\n        litemsgs.map(id => this.litestore.readLitemsg(id))\n      );\n      let blocks = await Promise.all(\n        [...new Set(lookup)]\n          .filter(id => id)\n          .map(id => this.blockchain.getBlock(id))\n      );\n\n      if (litemsgs.length) {\n        // send response\n        peer.sendJson(\n          litemsgLocators({ litemsgs, blocks, lookup })\n        );\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  getPendingMsgsHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let litemsgs = Object.keys(this.litemsgPool);\n\n      if (litemsgs.length) {\n        // send response\n        peer.sendJson(inv({ litemsgs }));\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  peerConnectHandler(peer) {\n    if (peer.nodeType === 'full' && this.node.peers('full').length === 1) {\n      // wait for 30 seconds to retrieve blocks\n      // because of concorrent resolving (it takes\n      // time to construct connections with peers)\n      setTimeout(() => {\n        let blockLocators = this.blockchain.getLocatorsSync();\n        peer.sendJson(getBlocks({ blockLocators }));\n      }, 60000);\n    }\n\n    peer._resolver = new InventoryResolver(peer, this);\n  }\n\n  close() {\n    for (let timer of this.timers) {\n      clearInterval(timer);\n    }\n    if (this.handshake) { this.handshake.close(); }\n    super.close();\n  }\n}\n\nmodule.exports = LiteProtocol;\n","const { sha256 } = require('../../utils/litecrypto');\n\n/**\n * Note for genesis block, its `height` must be 0, and `prevBlock` be `undefined`.\n * \n * All fields together except `litemsgs` are called block header, while `litemsgs`\n * is called block body.\n * \n * @param {*} ver         version number (now hardcoded to 1, I don't have time :|)\n * @param {*} time        timestamp (unix time)\n * @param {*} height\n * @param {*} prevBlock   previous block's id\n * @param {*} merkleRoot  merkle root\n * @param {*} bits        difficulty\n * @param {*} nonce       nonce\n * @param {*} litemsgs    an array of litemessages (not ids)\n */\nconst createBlock = (ver, time, height, prevBlock, merkleRoot, bits, nonce, litemsgs) => {\n  let hash = undefined;\n  if (typeof nonce === 'number') {\n    // only calculate hash when `nonce` is given\n    hash = sha256(`${ver}${time}${height}${prevBlock}${merkleRoot}${bits}${nonce}`);\n  }\n  return { ver, time, height, prevBlock, merkleRoot, bits, nonce, litemsgs, hash };\n};\n\nmodule.exports = createBlock;\n","if (BUILD_TARGET === 'node') {\n  // node (output as commonjs)\n\n  exports.Node = require('./src/clients/node');\n  exports.ThinNode = require('./src/clients/thinnode');\n  exports.FullNode = require('./src/clients/fullnode');\n\n  exports.createLitemsg = require('./src/liteprotocol/entities/litemsg');\n  exports.LiteProtocol = require('./src/liteprotocol/liteprotocol');\n  exports.ThinLiteProtocol = require('./src/liteprotocol/thinprotocol');\n  module.exports = exports =  { ...exports, ...require('./src/liteprotocol/messages') };\n\n  module.exports = exports = { ...exports, ...require('./src/utils/litecrypto') };\n  module.exports = exports = { ...exports, ...require('./src/utils/time') };\n  \n} else {\n  // browser (output as umd)\n\n  module.exports = exports = { ...exports, ...require('./src/utils/litecrypto') };\n}\n","module.exports = require(\"uuid/v1\");","module.exports = require(\"levelup\");","const WSClient = require('./wsc');\nconst { getSocketAddress } = require('./utils/network');\nconst { getCurTimestamp } = require('./utils/time');\n\nif (BUILD_TARGET === 'node') {\n  // running in node\n  var EventEmitter = require('events');\n  var WSServer = require('./wss');\n} else {\n  // running in browser\n  var EventEmitter = require('wolfy87-eventemitter');\n}\n\n/**\n * This class is the abstraction of \"node\" (litenode) inside the litemessage\n * peer-to-peer network. It is on top of Websocket layer by composing `WSServer`\n * when runing in nodejs environment, or `WSClient` when runing as \"thin\" node in\n * both nodejs and browser environments. \n * \n * This class is protocol-agnostic, meaning it doesn't assume any detail of\n * the implmentation of litemessage's protocol. Instead, it just provides some\n * APIs and async events for implementing the protocol and any kind of litemessage\n * client (\"thin\" / \"full\" node) on top of that.\n * \n * You must provide a UUID to the contructor. The UUID is the unique identifier \n * identify a unique node inside the peer-to-peer network.\n * \n * By default, node use 1113 as the daemon port inside the network.\n * \n * TODO log handshake communication traffic\n * TODO use debug config, also support cli to specify\n * TODO support specifying the interface to bind\n * \n * #### Events\n * - `socketconnect` - low level socket connection (simple wrapper around wss's)\n * - `peerconnect` - high level peer connection\n * - `peerdisconnect` - high level peer disconnection\n * - `message/${message_type}` - high level protocol-specific messages\n * \n * All other events are handled by low level abstraction, so you don't need to\n * worry about : P\n */\nclass LiteNode extends EventEmitter {\n  constructor(uuid, { port = 1113, debug = false, noserver = false } = {}) {\n    super();\n    this.socketConnectHandler = this.socketConnectHandler.bind(this);\n    this.socketMessageHandler = this.socketMessageHandler.bind(this);\n    this.socketCloseHandler = this.socketCloseHandler.bind(this);\n\n    this.uuid = uuid;\n    this.daemonPort = noserver ? undefined : port;\n    this.debugPort = port + 1;\n    this.noserver = noserver;\n\n    // node's uuid => peer\n    this.peers = {};\n    // remote socket addresses (str) => peers\n    this.socketsToPeers = {};\n\n    // used for debugging (view all protocol messages since start)\n    this.debug = debug;\n    this.messageLogs = [];\n\n    // create the underlyng websocket server\n    this.wss = noserver ? new WSClient() : new WSServer(port);\n    if (!noserver) {\n      // when bound to an network interface\n      this.wss.on('listening', (port) => {\n        console.log(`${uuid}: Start listening on port ${port}.`);\n        if (debug) { console.log('Debug mode is enabled.'); }\n      });\n    }\n    // when new connection established\n    this.wss.on('connection', this.socketConnectHandler);\n  }\n\n  /**\n   * Create a proxy to intercept the `send` function call,\n   * mainly for debugging / logging.\n   */\n  createSocketProxy(socket, remoteUuid) {\n    if (!this.debug) { return socket; }\n\n    const messageLogs = this.messageLogs;\n\n    const handler = {\n      get: (socket, propName) => {\n        if (propName !== 'send') { return socket[propName]; }\n        // return the wrapper function as a proxy\n        return function (data, options, callback) {\n          messageLogs.push({\n            peer: remoteUuid,\n            dir: 'outbound',\n            msg: JSON.parse(data),\n            time: getCurTimestamp('s')\n          });\n\n          return socket.send(data, options, callback);\n        };\n      }\n    };\n    // create socket proxy and return\n    return new Proxy(socket, handler);\n  }\n\n  /**\n   * Note that you cannot have more than one socket to a single URL.\n   * And also note that error could be thrown if url is invalid.\n   * Failure of connection will only cause some log (won't crash\n   * the application).\n   * \n   * Right now, there's no way to get notified when it fail to connect\n   * (such as because of timeout) except for a log mentioned before.\n   */\n  createConnection(url) {\n    return this.wss.createConnection(url);\n  }\n\n  /**\n   * @param {string} msg \n   * @param {Array<string>} exUuids \n   */\n  broadcast(msg, exUuids = []) {\n    let peers = Object.keys(this.peers)\n      .filter(uuid => !exUuids.includes(uuid))\n      .map(uuid => this.peers[uuid]);\n\n    for (let peer of peers) {\n      try {\n        peer.send(msg);\n      } catch (err) {\n        console.error(err);\n      }\n    }\n  }\n\n  /**\n   * @param {Object} jsonObj \n   * @param {Array<string>} exUuids \n   */\n  broadcastJson(jsonObj, exUuids) {\n    this.broadcast(JSON.stringify(jsonObj), exUuids);\n  }\n\n  socketConnectHandler(socket, incoming) {\n    let socketAddress = getSocketAddress(socket);\n    if (incoming) {\n      console.log(`Accepted socket connection from ${socketAddress}.`);\n    } else {\n      console.log(`Established socket connection to ${socketAddress}.`);\n    }\n\n    socket.on('close', (code, reason) =>\n      this.socketCloseHandler(code, reason, socket));\n\n    // notify listeners\n    this.emit('socketconnect', socket, incoming);\n  }\n\n  socketMessageHandler(msg, peer) {\n    let msgObj = null;\n    try { msgObj = JSON.parse(msg); } catch (e) {}\n    \n    if (msgObj && msgObj['messageType']) {\n      if (this.debug) {\n        // note that only logs valid procotol messages\n        this.messageLogs.push({\n          peer: peer.uuid,\n          dir: 'inbound',\n          msg: msgObj,\n          time: getCurTimestamp('s')\n        });\n      }\n\n      this.emit(`message/${msgObj['messageType']}`, msgObj, peer);\n    }\n  }\n\n  socketCloseHandler(code, reason, socket) {\n    let socketAddress = getSocketAddress(socket);\n    let peer = this.socketsToPeers[socketAddress]\n\n    if (peer) {\n      delete this.peers[peer.uuid];\n      delete this.socketsToPeers[socketAddress]\n      console.log(`Disconnected from ${peer.uuid}@${socketAddress}.`);\n      // notify listeners\n      this.emit('peerdisconnect', peer);\n    }\n    console.log(`Closed socket connection with ${socketAddress} (${code || 'N/A'} | ${reason || 'N/A'}).`);\n  }\n\n  /**\n   * Add new peer to peer collection of this node. The protocol\n   * implmementation should call this after a protocol-specific\n   * handshake completes (this class is protocol agnostic).\n   */\n  addNewPeer(peer) {\n    let { uuid, socket, incoming, nodeType } = peer;\n    let socketAddress = getSocketAddress(socket);\n\n    if (this.peers.hasOwnProperty(uuid)) {\n      console.warn(`Established connection with a connected peer (${uuid}@${socketAddress});\\n`\n        + `so, going to disconnect from it.`);\n      socket.close(undefined, 'DOUBLE_CONNECT');\n      return;\n    }\n\n    peer.socket = socket = this.createSocketProxy(socket, uuid);\n    this.peers[uuid] = peer;\n    this.socketsToPeers[socketAddress] = peer;\n    socket.on(BUILD_TARGET === 'node' ? 'message' : 'data', (message) => \n      this.socketMessageHandler(message, peer));\n\n    if (incoming) {\n      console.log(`Accepted connection from ${peer.uuid}@${socketAddress} (${nodeType}).`);\n    } else {\n      console.log(`Established connection to ${peer.uuid}@${socketAddress} (${nodeType}).`);\n    }\n\n    // notify listeners\n    this.emit('peerconnect', peer);\n  }\n\n  /**\n   * Get some useful information about this node.\n   */\n  getInfo() {\n    let network = this.wss.getInfo();\n\n    if (network.sockets) {\n      for (let socketInfo of network.sockets) {\n        let peer = this.socketsToPeers[socketInfo.remoteSocketAddr];\n\n        socketInfo.remoteUuid = peer.uuid;\n        socketInfo.remoteDaemonPort = peer.daemonPort;\n      }\n    }\n\n    return {\n      uuid: this.uuid,\n      daemonPort: this.daemonPort,\n      network,\n    };\n  }\n\n  /**\n   * Close this node (both server and outgoing socket connections will\n   * be closed)\n   */\n  close() {\n    this.removeAllListeners();\n    this.wss.close();\n  }\n}\n\nmodule.exports = LiteNode;\n","const { getSocketAddress, getSocketInfo, getReadyState } = require('./utils/network');\n\nif (BUILD_TARGET === 'node') {\n  // run in node\n\n  var EventEmitter = require('events');\n  var { URL } = require('url');\n  var WebSocket = require('ws');\n\n} else {\n  // run in browser\n\n  var EventEmitter = require('wolfy87-eventemitter');\n\n  // simple-websocket is an event-emitter based websocket\n  // implementation, which supports running in browser\n  var WebSocket = require('simple-websocket');\n  // shim some methods\n  Object.getPrototypeOf(WebSocket).close = function () {\n    this.destroy();\n  };\n  Object.getPrototypeOf(WebSocket).terminate = function () {\n    this.destroy();\n  };\n}\n\n/**\n * Provide abstraction for underlaying transportation protocol. It behaves \n * both like a server and a client - it will connect to several clients, \n * and also several servers (P2P network).\n * \n * The P2P network is a directed graph with bidirectional communication channels.\n * \n * ##### Events\n * - `connection` (socket, incoming) - low level socket connection\n * \n * For all other events, use the underlying web socket object.\n * \n * TODO shim ping/pong for browser env\n */\nclass WSClient extends EventEmitter {\n  constructor() {\n    super();\n    this.connectionHandler = this.connectionHandler.bind(this);\n    \n    // map remote socket addresses (ip:port) to sockets\n    this.servers = {};\n    \n    // set up heartbeats\n    if (BUILD_TARGET === 'node') {\n      this.timer = setInterval(this.genHeartbeat(), 60000);\n    }\n  }\n\n  /**\n   * Note that you cannot have more than one socket to a single URL.\n   * And also note that error could be thrown if url is invalid.\n   * Failure of connection will only cause some logs (won't crash\n   * the application).\n   * \n   * Right now, there's no way to get notified when it fails to connect\n   * (such as because of timeout) except for a log mentioned before.\n   */\n  createConnection(url) {\n    let socketAddress = null;\n    let remoteDaemonPort = null;\n    try {\n      ({ host: socketAddress, port: remoteDaemonPort } = new URL(url));\n      if (!socketAddress || !remoteDaemonPort.match(/^\\d+$/)) { throw new Error(); }\n    } catch (err) {\n      throw new Error(`Wrong url (${url}) to connect.`);\n    }\n\n    let prevSocket = this.servers[socketAddress];\n    if (prevSocket && this.socketAlive(prevSocket)) {\n      console.warn(`Tried to connect to same url (${url}) twice. Operation aborted.`);\n      return;\n    }\n\n    let socket = new WebSocket(url, { handshakeTimeout: 10000 });\n\n    socket.on('error', (err) =>\n      console.log(`Unable to establish connection to ${url}. Details:\\n${err}.`));\n\n    socket.on(BUILD_TARGET === 'node' ? 'open' : 'connect', () => {\n      let prevSocket = this.servers[socketAddress];\n      if (prevSocket && this.socketAlive(prevSocket)) {\n        // TODO investigate memory leak\n        socket.on('close', () => socket.removeAllListeners());\n        socket.close(undefined, 'DOUBLE_CONNECT');\n        return;\n      }\n      socket.removeAllListeners('error');\n      this.connectionHandler(socket, false);\n      this.servers[socketAddress] = socket;\n    });\n  }\n\n  genHeartbeat() {\n    let noop = () => {};\n    return () => {\n      for (let socket of Object.values(this.servers)) {\n        if (this.socketAbnormal(socket)) {\n          socket.terminate();\n        }\n        // set socket `alive` to false, later pong response\n        // from client will recover `alive` from false to true\n        socket.alive = false;\n        socket.ping(noop);\n      }\n    }\n  }\n\n  /**\n   * @param {*} socket                  the underlaying socket\n   * @param {boolean} incoming          whether the connection is incoming\n   */\n  connectionHandler(socket, incoming) {\n    let socketAddress = getSocketAddress(socket);\n    socket.alive = true;\n    socket.on('message', () => socket.alive = true);\n    socket.on('pong', () => socket.alive = true);\n    socket.on('close', () => {\n      socket.alive = false;\n      socket.removeAllListeners();\n      if (socket === this.servers[socketAddress]) {\n        delete this.servers[socketAddress];\n      }\n    });\n    socket.on('error', err => {\n      console.log(err);\n      socket.terminate();\n    });\n    // notify subscribers\n    this.emit('connection', socket, incoming);\n  }\n\n  socketAbnormal(socket) {\n    return !socket.alive && getReadyState(socket) === WebSocket.OPEN;\n  }\n\n  socketAlive(socket) {\n    return getReadyState(socket) === WebSocket.OPEN;\n  }\n\n  /**\n   * Get some useful information about the network.\n   */\n  getInfo() {\n    let sockets = [];\n\n    for (let socket of Object.values(this.servers)) {\n      sockets.push({\n        dir: 'outbound',\n        ...getSocketInfo(socket)\n      });\n    }\n\n    return {\n      sockets\n    };\n  }\n\n  /**\n   * Close this node (both server and outgoing socket connections will\n   * be closed)\n   */\n  close() {\n    this.removeAllListeners();\n    clearInterval(this.timer);\n  }\n}\n\nmodule.exports = WSClient;\n","const EventEmitter = require('events');\nconst WebSocket = require('ws');\nconst { URL } = require('url');\nconst { getSocketAddress, getSocketInfo } = require('./utils/network');\n\n/**\n * Provide abstraction for underlaying transportation protocol. It behaves \n * both like a server and a client - it will connect to several clients, \n * and also several servers (P2P network).\n * \n * The P2P network is a directed graph with bidirectional communication channels.\n * \n * TODO docker delievery\n * TODO investigate event emitter memory leak\n * TODO close reason doesn't work\n * \n * ##### Events\n * - `listening` (port: string) - when the underlying ws server binds successfully\n * - `connection` (socket, incoming) - low level socket connection\n * \n * For all other events, use the underlying web socket object.\n */\nclass WSServer extends EventEmitter {\n  constructor(port) {\n    super();\n    this.connectionHandler = this.connectionHandler.bind(this);\n    \n    // map remote socket addresses (ip:port) to sockets\n    this.servers = {};\n    this.port = port;\n    \n    // create underlaying server and listen\n    this.wss = new WebSocket.Server({ port });\n    // when bound to an network interface\n    this.wss.on('listening', () => this.emit('listening', port));\n    // when receiving incoming connection\n    this.wss.on('connection', (socket, req) => {\n      this.connectionHandler(socket, true);\n    });\n    // when websocket server has error (don't crash it)\n    this.wss.on('error', console.log);\n\n    // set up heartbeats\n    this.timer = setInterval(this.genHeartbeat(), 60000);\n  }\n\n  /**\n   * Note that you cannot have more than one socket to a single URL.\n   * And also note that error could be thrown if url is invalid.\n   * Failure of connection will only cause some logs (won't crash\n   * the application).\n   * \n   * Right now, there's no way to get notified when it fails to connect\n   * (such as because of timeout) except for a log mentioned before.\n   */\n  createConnection(url) {\n    let socketAddress = null;\n    let remoteDaemonPort = null;\n    try {\n      ({ host: socketAddress, port: remoteDaemonPort } = new URL(url));\n      if (!socketAddress || !remoteDaemonPort.match(/^\\d+$/)) { throw new Error(); }\n    } catch (err) {\n      throw new Error(`Wrong url (${url}) to connect.`);\n    }\n\n    let prevSocket = this.servers[socketAddress];\n    if (prevSocket && this.socketAlive(prevSocket)) {\n      console.warn(`Tried to connect to same url (${url}) twice. Operation aborted.`);\n      return;\n    }\n\n    let socket = new WebSocket(url, { handshakeTimeout: 10000 });\n\n    socket.on('error', (err) =>\n      console.log(`Unable to establish connection to ${url}. Details:\\n${err}.`));\n\n    socket.on('open', () => {\n      let prevSocket = this.servers[socketAddress];\n      if (prevSocket && this.socketAlive(prevSocket)) {\n        // TODO investigate memory leak\n        socket.on('close', () => socket.removeAllListeners());\n        socket.close(undefined, 'DOUBLE_CONNECT');\n        return;\n      }\n      socket.removeAllListeners('error');\n      this.connectionHandler(socket, false);\n      this.servers[socketAddress] = socket;\n    });\n  }\n\n  genHeartbeat() {\n    let noop = () => {};\n    return () => {\n      for (let socket of [...this.wss.clients, ...Object.values(this.servers)]) {\n        if (this.socketAbnormal(socket)) {\n          socket.terminate();\n        }\n        // set socket `alive` to false, later pong response\n        // from client will recover `alive` from false to true\n        socket.alive = false;\n        socket.ping(noop);\n      }\n    }\n  }\n\n  /**\n   * @param {*} socket                  the underlaying socket\n   * @param {boolean} incoming          whether the connection is incoming\n   */\n  connectionHandler(socket, incoming) {\n    let socketAddress = getSocketAddress(socket);\n    socket.alive = true;\n    socket.on('message', () => socket.alive = true);\n    socket.on('pong', () => socket.alive = true);\n    socket.on('close', () => {\n      socket.alive = false;\n      socket.removeAllListeners();\n      if (socket === this.servers[socketAddress]) {\n        delete this.servers[socketAddress];\n      }\n    });\n    socket.on('error', err => {\n      console.log(err);\n      socket.terminate();\n    });\n    // notify subscribers\n    this.emit('connection', socket, incoming);\n  }\n\n  socketAbnormal(socket) {\n    return !socket.alive && socket.readyState === WebSocket.OPEN;\n  }\n\n  socketAlive(socket) {\n    return socket.readyState === WebSocket.OPEN;\n  }\n\n  /**\n   * Get some useful information about the network.\n   */\n  getInfo() {\n    let sockets = [];\n\n    for (let socket of this.wss.clients) {\n      sockets.push({\n        dir: 'inbound',\n        ...getSocketInfo(socket)\n      });\n    }\n    for (let socket of Object.values(this.servers)) {\n      sockets.push({\n        dir: 'outbound',\n        ...getSocketInfo(socket)\n      });\n    }\n\n    return {\n      port: this.port,\n      sockets\n    };\n  }\n\n  /**\n   * Close this node (both server and outgoing socket connections will\n   * be closed)\n   */\n  close() {\n    this.removeAllListeners();\n    clearInterval(this.timer);\n    this.wss.close();\n  }\n}\n\nmodule.exports = WSServer;\n","module.exports = require(\"fs\");","module.exports = require(\"leveldown\");","const Node = require('./node');\nconst ThinLiteProtocol = require('../liteprotocol/thinprotocol');\n\nconst NODE_TYPE = 'thin';\n\nclass ThinNode extends Node {\n  constructor(dbPath, { protocolClass = ThinLiteProtocol, initPeerUrls = [], port, debug } = {}) {\n    super(NODE_TYPE, dbPath, port, protocolClass, initPeerUrls, debug, true);\n  }\n\n  static get nodeType() {\n    return NODE_TYPE;\n  }\n\n  close() {\n    super.close();\n  }\n}\n\nmodule.exports = ThinNode;\n","const prefix = 'p2p/';\n\nconst genKey = key => prefix + key;\n\nclass P2PProtocolStore {\n  constructor(db) {\n    this.db = db;\n  }\n\n  /**\n   * Flush current connected peers' URLs into DB. \n   * Note that you should only provide peers with \n   * desired `nodeType`s.\n   */\n  async writeCurPeerUrls(peerUrls) {\n    let data = JSON.stringify(peerUrls);\n    return this.db.put(genKey('cur_peer_urls'), data);\n  }\n\n  async readCurPeerUrls() {\n    try {\n      let buf = await this.db.get(genKey('cur_peer_urls'));\n      return JSON.parse(buf.toString());\n    } catch (err) {\n      if (err.notFound) { return []; }\n      throw err;\n    }\n  }\n}\n\nmodule.exports = P2PProtocolStore;\n","// message type constants\nconst messageTypes = Object.freeze({\n  fetchPeers: 'p2p/fetch_peers',\n  returnPeers: 'p2p/return_peers'\n});\n\n\n/**\n * \n */\nconst fetchPeers = ({ nodeTypes, limit = 20 } = {}) => ({\n  messageType: messageTypes.fetchPeers, \n  nodeTypes, \n  limit\n});\n\nfetchPeers.validate = ({ nodeTypes, limit }) => {\n  if (!(nodeTypes instanceof Array) || nodeTypes.length === 0) {\n    throw new Error('p2p/: Invalid message, field nodeTypes.');\n  }\n  if (typeof limit !== 'number' || limit <= 0) {\n    throw new Error('p2p/: Invalid message, field limit.');\n  }\n};\n\n\n/**\n * \n */\nconst returnPeers = ({ nodeTypes, peerUrls = [] } = {}) => ({\n  messageType: messageTypes.returnPeers, \n  nodeTypes, \n  peerUrls\n});\n\nreturnPeers.validate = ({ nodeTypes, peerUrls }) => {\n  if (!(nodeTypes instanceof Array) || nodeTypes.length === 0) {\n    throw new Error('p2p/: Invalid message, field nodeTypes.');\n  }\n  if (!(peerUrls instanceof Array)) {\n    throw new Error('p2p/: Invalid message, field peerUrls.');\n  }\n};\n\n\n// validators\nconst messageValidators = Object.freeze({\n  [messageTypes.fetchPeers]: fetchPeers.validate,\n  [messageTypes.returnPeers]: returnPeers.validate\n});\n\n\nexports.messageTypes = messageTypes;\nexports.messageValidators = messageValidators;\nexports.fetchPeers = fetchPeers;\nexports.returnPeers = returnPeers;\n","module.exports = require(\"dns\");","module.exports = require(\"util\");","const { getRemoteAddress, getSocketAddress } = require('./utils/network');\n\nclass Peer {\n  /**\n   * @param {string} uuid             peer's uuid\n   * @param {*} socket                network socket to the peer\n   * @param {boolean} incoming        whether the connection is incoming\n   * @param {string} daemonPort       peer's daemon port\n   * @param {string} nodeType         peer's node type\n   */\n  constructor(uuid, socket, incoming, daemonPort, nodeType) {\n    this.uuid = uuid;\n    this.socket = socket;\n    this.incoming = incoming;\n    this.daemonPort = daemonPort;\n    this.nodeType = nodeType;\n    this.url = `ws://${getRemoteAddress(socket)}:${daemonPort}`;\n  }\n\n  /**\n   * Note that error might be thrown, such as when trying to \n   * send data through closed connection (very rare though - the\n   * underlaying litenode will take care of that).\n   * \n   * @param {string} message to send\n   */\n  send(msg) {\n    this.socket.send(msg);\n  }\n\n  /**\n   * Note that error might be thrown, such as when trying to \n   * send data through closed connection (very rare though - the\n   * underlaying litenode will take care of that).\n   * \n   * @param {Object} jsonObj object to send\n   */\n  sendJson(jsonObj) {\n    this.send(JSON.stringify(jsonObj));\n  }\n\n  toString() {\n    return `${this.nodeType} - ${this.url}`;\n  }\n\n  toJSON() {\n    return {\n      uuid: this.uuid,\n      remoteAddr: getSocketAddress(this.socket),\n      daemonPort: this.daemonPort,\n      incoming: this.incoming,\n      type: this.nodeType\n    };\n  }\n}\n\nmodule.exports = Peer;\n","module.exports = require(\"crypto\");","module.exports = require(\"child_process\");","module.exports = require(\"bluebird\");","module.exports = require(\"buffer\");","module.exports = require(\"http\");","module.exports = require(\"express\");","module.exports = require(\"morgan\");","module.exports = require(\"cookie-parser\");","module.exports = require(\"body-parser\");","const Node = require('./node');\nconst LiteProtocol = require('../liteprotocol/liteprotocol');\n\nconst NODE_TYPE = 'full';\n\n/**\n * The Litemessage fully functional node client.\n * \n * TODO fails to bind should crash the client imediately\n */\nclass FullNode extends Node {\n  constructor(dbPath, { protocolClass = LiteProtocol, initPeerUrls = [], port, debug } = {}) {\n    super(NODE_TYPE, dbPath, port, protocolClass, initPeerUrls, debug);\n\n    this.timer = setInterval(() => {\n      console.log(`Right now, there are ${this.peers().length} connected peers (full & thin).`);\n      // TODO this.debugInfo();\n    }, 20000);\n  }\n\n  static get nodeType() {\n    return NODE_TYPE;\n  }\n\n  close() {\n    clearInterval(this.timer);\n    super.close();\n  }\n\n  // TODO\n  debugInfo() {\n    console.log('<<<<< debug start >>>>>');\n    let peerUrls = this.peers().map(peer => peer.url);\n    console.log(peerUrls);\n    console.log('<<<<<< debug end >>>>>>');\n  }\n}\n\nmodule.exports = FullNode;\n","const { mine } = require('../utils/litecrypto');\nconst createBlock = require('./entities/block');\n\n/**\n * mining manager : )\n */\nclass Miner {\n  /**\n   * Use `mine` down below; it has easier interface.\n   * \n   * Start mining. If at the point you call this function,\n   * a mining is going on, that mining will be canceled\n   * automatically (right now doesn't support concurrent\n   * mining).\n   * \n   * Note that if the mining is canceled, it won't trigger\n   * `resolve` or `reject` of the returned promise.\n   */\n  calc(content, bits) {\n    if (this.mining) { this.cancel(); }\n    this.mining = mine(content, bits);\n    return this.mining\n      .then(nonce => {\n        this.mining = null;\n        return nonce;\n      })\n      .catch(err => {\n        this.mining = null;\n        throw err;\n      });\n  }\n\n  /**\n   * Note that it won't change the orginal block, but return a new\n   * successfully mined block.\n   * \n   * @param {*} block \n   */\n  mine(block) {\n    const { ver, time, height, prevBlock, merkleRoot, bits, litemsgs } = block;\n    const content = `${ver}${time}${height}${prevBlock}${merkleRoot}${bits}`;\n    return this.calc(content, bits)\n      .then(nonce => \n        createBlock(ver, time, height, prevBlock, merkleRoot, bits, nonce, litemsgs));\n  }\n\n  cancel() {\n    if (this.mining) {\n      this.mining.cancel();\n      this.mining = null;\n    }\n  }\n}\n\nmodule.exports = Miner;\n","const {\n  messageTypes, messageValidators, dataPartial, \n  partialNotFound\n} = require('./messages');\n\n/**\n * This inventory resolve handler is used to serve requests\n * sent by inventory resolvers.\n * \n * For nodes supporting serving the new inventory resolution\n * mechanism, you need to instantiate this handler when\n * bootstrapping the protocol.\n */\nclass InvResolveHandler {\n  constructor(liteprotocol) {\n    this.getDataPartialHandler = this.getDataPartialHandler.bind(this);\n\n    this.litenode = liteprotocol.litenode;\n    this.blockchain = liteprotocol.blockchain;\n\n    this.litenode.on(`message/${messageTypes.getDataPartial}`, this.getDataPartialHandler);\n  }\n\n  async getDataPartialHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { merkleDigest, blocks: blockIds } = payload;\n      let blocks = await Promise.all(\n        blockIds.map(id => this.blockchain.getBlock(id))\n      );\n\n      if (blocks.some(block => !block)) {\n        peer.sendJson(\n          partialNotFound({\n            merkleDigest, \n            blocks: blockIds\n          })\n        ); // end of sendJson\n\n      } else {\n        peer.sendJson(\n          dataPartial({\n            merkleDigest,\n            blocks\n          })\n        ); // end of sendJson\n      } // end of else\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n}\n\nmodule.exports = InvResolveHandler;\n","const { sliceItems } = require('../utils/common');\nconst { getCurTimestamp } = require('../utils/time');\nconst { calcMerkleRoot, verifyBlock } = require('../utils/litecrypto');\nconst {\n  messageTypes, messageValidators, getData, data,\n  getDataPartial\n} = require('./messages');\n\n/**\n * Abstraction of the inventory (only for blocks) to resolve.\n */\nclass BlockInventory {\n  /**\n   * @param {*} blocks block ids\n   * @param {*} slices number of slices   \n   */\n  constructor(blocks, slices) {\n    // chain's merkle digest\n    this.merkleDigest = calcMerkleRoot(blocks);\n    // chunk digest (sub merkle) => chunk data\n    this.chunks = {};\n    // the timestamp when resolving given blocks\n    this.timestamp = null;\n\n    for (let blockIds of sliceItems(blocks, slices)) {\n      let digest = calcMerkleRoot(blockIds);\n\n      this.chunks[digest] = {\n        // merkle root digest\n        digest,\n        // the block ids\n        ids: blockIds,\n        // the actual block data\n        blocks: undefined,\n        // the timestamp when resolving each chunk\n        timestamp: undefined\n      };\n    }\n  }\n\n  * [Symbol.iterator]() {\n    for (let chunk of Object.values(this.chunks)) {\n      yield chunk;\n    }\n  }\n\n  getBlocks() {\n    let blockArrays = Object.values(this.chunks).map(chunk => chunk.blocks);\n    let blocks = [];\n\n    for (let array of blockArrays) {\n      blocks.push(...array);\n    }\n    return blocks;\n  }\n\n  /**\n   * Whether this block inventory is resolved (a boolean).\n   */\n  resolved() {\n    for (let chunk of this) {\n      if (!chunk.blocks) { return false; }\n    }\n    return true;\n  }\n}\n\nconst RESOLV_TIMEOUT = 90000;\n\n/**\n * This class is an abstraction of inventory resolver, which uses\n * specific types of protocol messages (namely, `getDataPartial`, \n * `dataPartial`, and `partialNotFound`) to enable resolving inventory\n * objects by communicating MULTIPLE peers in parallel, mainly for\n * better efficiency and scalability.\n * \n * Resolving inventory objects here just means to convert block id or\n * message id to the actual corresponding block or message data.\n * \n * The logic here is almost transparent to the rest of the protocol\n * implementation, except you have to call the interface exposed here\n * if you want to optionally jump in the performance & scalability\n * optimization provided by this class.\n * \n * Note that the resolved blocks will only go through some basic\n * veriffication - more specificlly, to be individually verified.\n * Since this is mostly transparent to other modules, all existing\n * verificaitions afterwards will be invoked automatically. There\n * is no need to do thorough veirification here.\n * \n * TODO implement `partialNotFoundHandler`\n * TODO only create resolver when peer is \"full\" node\n * TODO receiving invalid blocks from non-target peers cuases timeout\n * TODO disconnection from non-target peers causes timeout\n * TODO when receiving invalid blocks from target peer, abort resolving\n *      immediately\n */\nclass InventoryResolver {\n  /**\n   * @param {*} socket        the peer whose inventory needs to resolve\n   * @param {*} liteprotocol  the protocol implementation itself\n   * @param {*} options\n   *                `slices`  number of slices\n   *        `blockThreshold`  the length threshold for sub blockchain. When\n   *                          sub blockchain's length is less than this\n   *                          threshold, the resolving will fall back\n   *                          to original approach (only by communicating one\n   *                          peer), which is via the `getData` message type.\n   *                          By default, this is undefined - always using\n   *                          parallel resolving.\n   */\n  constructor(peer, liteprotocol, { slices = 10, blockThreshold = 1000 } = {}) {\n    this.peerDisconnectHandler = this.peerDisconnectHandler.bind(this);\n    this.dataPartialHandler = this.dataPartialHandler.bind(this);\n    this.partialNotFoundHandler = this.partialNotFoundHandler.bind(this);\n\n    this.peer = peer;\n    this.node = liteprotocol.node;\n    this.litenode = liteprotocol.litenode;\n    this.blockchain = liteprotocol.blockchain;\n    this.slices = slices;\n    this.blockThreshold = blockThreshold;\n\n    // merkle digest => block inventory to resolve\n    this.blockInventories = {};\n\n    this.litenode.on(`message/${messageTypes.dataPartial}`, this.dataPartialHandler);\n    this.litenode.on(`message/${messageTypes.partialNotFound}`, this.partialNotFoundHandler);\n    this.litenode.on('peerdisconnect', this.peerDisconnectHandler);\n\n    this.timer = setInterval(() => {\n      let now = getCurTimestamp();\n\n      for (let blockInv of Object.values(this.blockInventories)) {\n        // filter to get those timeout chunks\n        let chunks = [...blockInv].filter(chunk => \n          !chunk.blocks && now - chunk.timestamp >= RESOLV_TIMEOUT);\n        \n        if (chunks.some(chunk => chunk.peer.uuid === this.peer.uuid)) {\n          // abort resolving\n          delete this.blockInventories[ blockInv.merkleDigest ];\n          continue;\n        }\n\n        for (let chunk of chunks) {\n          this._resolveChunk(chunk, this.peer, blockInv);\n        }\n      } // end of loop\n\n    }, 30000);\n  }\n\n  /**\n   * Resolve the chunk (a slice of block inventory) by using\n   * the given peer. You should also pass the block inventory\n   * to which the chunk belongs.\n   */\n  _resolveChunk(chunk, peer, blockInv) {\n    peer.sendJson(\n      getDataPartial({\n        merkleDigest: blockInv.merkleDigest, \n        blocks: chunk.ids\n      })\n    );\n\n    chunk.timestamp = getCurTimestamp();\n    chunk.peer = peer;\n  }\n\n  _resolveBlocks(blocks) {\n    if (blocks.length < this.blockThreshold) {\n      this.peer.sendJson(getData({ blocks }));\n    }\n\n    let blockInv = new BlockInventory(blocks, this.slices);\n    let chunks = [...blockInv];\n    let peers = this.node.peers('full');\n\n    if (this.blockInventories[ blockInv.merkleDigest ]) {\n      return;\n    }\n\n    // using round robin across peers\n    for (let i = 0; i < chunks.length; i++) {\n      // make sure request the last (latest) chunk\n      // from the peer which is the owner of the \n      // inventory to be resolved here (because\n      // other peers might not have the latest\n      // blocks of the chunk just mined)\n      let peer = i + 1 === chunks.length ?\n        this.peer : peers[i % peers.length];\n\n      this._resolveChunk(chunks[i], peer, blockInv);\n    } // end of loop\n    \n    this.blockInventories[ blockInv.merkleDigest ] = blockInv;\n  }\n\n  _resolveLitemsgs(litemsgs) {\n    this.peer.sendJson(getData({ litemsgs }));\n  }\n\n  /**\n   * Note you don't have to provide the exact raw `inv` message\n   * here, but just an `inv`-like object. An `inv`-like object\n   * is any object which has either `blocks` or `litemsgs`\n   * properties, or both to resolve.\n   * \n   * @param {*} inv an `inv`-like object here\n   */\n  resolve({ blocks = [], litemsgs = [] }) {\n    if (blocks.length) {\n      this._resolveBlocks(blocks);\n    }\n    if (litemsgs.length) {\n      this._resolveLitemsgs(litemsgs);\n    }\n  }\n\n  async dataPartialHandler({ messageType, ...payload }, peer) {\n    try {\n      messageValidators[messageType](payload);\n      let { merkleDigest, blocks } = payload;\n      let blockInv = this.blockInventories[merkleDigest];\n      if (!blockInv) { /* not interested in the resolved blocks */ return; }\n\n      // Here we just verify the resolved blocks separately,\n      // the reason is explained in the doc on this resolver\n      // class.\n      blocks = blocks.filter(block => verifyBlock(block));\n      let blockIds = blocks.map(block => block.hash);\n      let chunk = blockInv.chunks[calcMerkleRoot(blockIds)];\n      if (!chunk || chunk.blocks) { return; }\n\n      // save block data to inventory\n      chunk.blocks = blocks;\n\n      if (blockInv.resolved()) {\n        this.litenode.emit(\n          `message/${messageTypes.data}`, \n          data({ blocks: blockInv.getBlocks() }),\n          this.peer\n        );\n\n        delete this.blockInventories[merkleDigest];\n      }\n\n    } catch (err) {\n      console.warn(err);\n    }\n  }\n\n  async partialNotFoundHandler({ messageType, ...payload }, peer) {\n    // TODO\n  }\n\n  peerDisconnectHandler(peer) {\n    if (peer.uuid !== this.peer.uuid) { return; }\n\n    clearInterval(this.timer);\n    this.litenode.removeListener(`message/${messageTypes.dataPartial}`, this.dataPartialHandler);\n    this.litenode.removeListener(`message/${messageTypes.partialNotFound}`, this.partialNotFoundHandler);\n    this.litenode.removeListener('peerdisconnect', this.peerDisconnectHandler);\n  }\n}\n\nmodule.exports = InventoryResolver;\n","const { sha256 } = require('../../utils/litecrypto');\n\n/**\n * @param {string} ver      version number (now hardcoded to 1, I don't have time :|)\n * @param {int} time        timestamp (unix time)\n * @param {string} litemsg  litemessage itself\n * @param {string} sig      signature\n * @param {string} pubKey   public key\n */\nconst createLitemsg = (ver, time, litemsg, sig, pubKey) => {\n  let hash = sha256(`${ver}${time}${litemsg}${sig}${pubKey}`);\n  return { ver, time, litemsg, sig, pubKey, hash };\n};\n\nmodule.exports = createLitemsg;\n"],"sourceRoot":""}